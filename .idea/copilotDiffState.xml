<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/app/auth/dropbox/callback/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/auth/dropbox/callback/page.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;import { Suspense, useEffect } from 'react';&#10;import { useSearchParams } from 'next/navigation';&#10;&#10;function DropboxCallbackContent() {&#10;  const searchParams = useSearchParams();&#10;&#10;  useEffect(() =&gt; {&#10;    const code = searchParams.get('code');&#10;    const error = searchParams.get('error');&#10;&#10;    if (error) {&#10;      // Send error to parent window&#10;      window.opener?.postMessage({&#10;        type: 'DROPBOX_AUTH_ERROR',&#10;        error: error&#10;      }, window.location.origin);&#10;      window.close();&#10;      return;&#10;    }&#10;&#10;    if (code) {&#10;      // Exchange code for access token&#10;      exchangeCodeForToken(code);&#10;    }&#10;  }, [searchParams]);&#10;&#10;  const exchangeCodeForToken = async (code: string) =&gt; {&#10;    try {&#10;      const response = await fetch('/api/auth/dropbox/token', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json',&#10;        },&#10;        body: JSON.stringify({ code })&#10;      });&#10;&#10;      if (!response.ok) {&#10;        throw new Error('Token exchange failed');&#10;      }&#10;&#10;      const tokenData = await response.json();&#10;      &#10;      // Send success data to parent window&#10;      window.opener?.postMessage({&#10;        type: 'DROPBOX_AUTH_SUCCESS',&#10;        accessToken: tokenData.access_token,&#10;        refreshToken: tokenData.refresh_token,&#10;        expiresAt: Date.now() + (tokenData.expires_in * 1000),&#10;        userId: tokenData.account_id,&#10;        displayName: tokenData.account_id // Dropbox doesn't provide display name in token response&#10;      }, window.location.origin);&#10;      &#10;      window.close();&#10;    } catch (error) {&#10;      console.error('Token exchange error:', error);&#10;      window.opener?.postMessage({&#10;        type: 'DROPBOX_AUTH_ERROR',&#10;        error: 'Token exchange failed'&#10;      }, window.location.origin);&#10;      window.close();&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;flex min-h-screen items-center justify-center p-8&quot;&gt;&#10;      &lt;div className=&quot;text-center&quot;&gt;&#10;        &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;Dropbox 인증 중...&lt;/h1&gt;&#10;        &lt;p className=&quot;text-zinc-600&quot;&gt;인증을 처리하고 있습니다. 잠시만 기다려주세요.&lt;/p&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;export default function DropboxCallback() {&#10;  return (&#10;    &lt;Suspense fallback={&#10;      &lt;div className=&quot;flex min-h-screen items-center justify-center p-8&quot;&gt;&#10;        &lt;div className=&quot;text-center&quot;&gt;&#10;          &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;로딩 중...&lt;/h1&gt;&#10;          &lt;p className=&quot;text-zinc-600&quot;&gt;잠시만 기다려주세요.&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    }&gt;&#10;      &lt;DropboxCallbackContent /&gt;&#10;    &lt;/Suspense&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#13;&#10;&#13;&#10;import { Suspense, useEffect } from 'react';&#13;&#10;import { useSearchParams } from 'next/navigation';&#13;&#10;&#13;&#10;function DropboxCallbackContent() {&#13;&#10;  const searchParams = useSearchParams();&#13;&#10;&#13;&#10;  useEffect(() =&gt; {&#13;&#10;    const code = searchParams.get('code');&#13;&#10;    const error = searchParams.get('error');&#13;&#10;&#13;&#10;    // 부모 창의 origin을 가져오기 (더 안전한 방법)&#13;&#10;    const getParentOrigin = () =&gt; {&#13;&#10;      try {&#13;&#10;        return window.opener?.location.origin || '*';&#13;&#10;      } catch (e) {&#13;&#10;        // Cross-origin 접근 불가 시 와일드카드 사용 (보안상 주의)&#13;&#10;        return '*';&#13;&#10;      }&#13;&#10;    };&#13;&#10;&#13;&#10;    if (error) {&#13;&#10;      // Send error to parent window&#13;&#10;      const targetOrigin = getParentOrigin();&#13;&#10;      window.opener?.postMessage({&#13;&#10;        type: 'DROPBOX_AUTH_ERROR',&#13;&#10;        error: error&#13;&#10;      }, targetOrigin);&#13;&#10;      window.close();&#13;&#10;      return;&#13;&#10;    }&#13;&#10;&#13;&#10;    if (code) {&#13;&#10;      // Exchange code for access token&#13;&#10;      exchangeCodeForToken(code);&#13;&#10;    }&#13;&#10;  }, [searchParams]);&#13;&#10;&#13;&#10;  const exchangeCodeForToken = async (code: string) =&gt; {&#13;&#10;    try {&#13;&#10;      const response = await fetch('/api/auth/dropbox/token', {&#13;&#10;        method: 'POST',&#13;&#10;        headers: {&#13;&#10;          'Content-Type': 'application/json',&#13;&#10;        },&#13;&#10;        body: JSON.stringify({ code })&#13;&#10;      });&#13;&#10;&#13;&#10;      if (!response.ok) {&#13;&#10;        throw new Error('Token exchange failed');&#13;&#10;      }&#13;&#10;&#13;&#10;      const tokenData = await response.json();&#13;&#10;      &#13;&#10;      // 부모 창의 origin을 가져오기&#13;&#10;      const getParentOrigin = () =&gt; {&#13;&#10;        try {&#13;&#10;          return window.opener?.location.origin || '*';&#13;&#10;        } catch (e) {&#13;&#10;          return '*';&#13;&#10;        }&#13;&#10;      };&#13;&#10;      &#13;&#10;      const targetOrigin = getParentOrigin();&#13;&#10;      &#13;&#10;      // Send success data to parent window&#13;&#10;      window.opener?.postMessage({&#13;&#10;        type: 'DROPBOX_AUTH_SUCCESS',&#13;&#10;        accessToken: tokenData.access_token,&#13;&#10;        refreshToken: tokenData.refresh_token,&#13;&#10;        expiresAt: Date.now() + (tokenData.expires_in * 1000),&#13;&#10;        userId: tokenData.account_id,&#13;&#10;        displayName: tokenData.account_id // Dropbox doesn't provide display name in token response&#13;&#10;      }, targetOrigin);&#13;&#10;      &#13;&#10;      window.close();&#13;&#10;    } catch (error) {&#13;&#10;      console.error('Token exchange error:', error);&#13;&#10;      &#13;&#10;      const getParentOrigin = () =&gt; {&#13;&#10;        try {&#13;&#10;          return window.opener?.location.origin || '*';&#13;&#10;        } catch (e) {&#13;&#10;          return '*';&#13;&#10;        }&#13;&#10;      };&#13;&#10;      &#13;&#10;      const targetOrigin = getParentOrigin();&#13;&#10;      &#13;&#10;      window.opener?.postMessage({&#13;&#10;        type: 'DROPBOX_AUTH_ERROR',&#13;&#10;        error: 'Token exchange failed'&#13;&#10;      }, targetOrigin);&#13;&#10;      window.close();&#13;&#10;    }&#13;&#10;  };&#13;&#10;&#13;&#10;  return (&#13;&#10;    &lt;div className=&quot;flex min-h-screen items-center justify-center p-8&quot;&gt;&#13;&#10;      &lt;div className=&quot;text-center&quot;&gt;&#13;&#10;        &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;Dropbox 인증 중...&lt;/h1&gt;&#13;&#10;        &lt;p className=&quot;text-zinc-600&quot;&gt;인증을 처리하고 있습니다. 잠시만 기다려주세요.&lt;/p&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    &lt;/div&gt;&#13;&#10;  );&#13;&#10;}&#13;&#10;&#13;&#10;export default function DropboxCallback() {&#13;&#10;  return (&#13;&#10;    &lt;Suspense fallback={&#13;&#10;      &lt;div className=&quot;flex min-h-screen items-center justify-center p-8&quot;&gt;&#13;&#10;        &lt;div className=&quot;text-center&quot;&gt;&#13;&#10;          &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;로딩 중...&lt;/h1&gt;&#13;&#10;          &lt;p className=&quot;text-zinc-600&quot;&gt;잠시만 기다려주세요.&lt;/p&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    }&gt;&#13;&#10;      &lt;DropboxCallbackContent /&gt;&#13;&#10;    &lt;/Suspense&gt;&#13;&#10;  );&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/auth/google/callback/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/auth/google/callback/page.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;import { useEffect, Suspense } from 'react';&#10;import { useSearchParams } from 'next/navigation';&#10;&#10;function GoogleCallbackContent() {&#10;  const searchParams = useSearchParams();&#10;&#10;  useEffect(() =&gt; {&#10;    const code = searchParams.get('code');&#10;    const error = searchParams.get('error');&#10;&#10;    if (error) {&#10;      // OAuth 에러 처리&#10;      window.opener?.postMessage({&#10;        type: 'GOOGLE_AUTH_ERROR',&#10;        error: error&#10;      }, window.location.origin);&#10;      window.close();&#10;      return;&#10;    }&#10;&#10;    if (code) {&#10;      // Authorization code를 access token으로 교환&#10;      fetch('/api/auth/google/token', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json'&#10;        },&#10;        body: JSON.stringify({ code })&#10;      })&#10;      .then(response =&gt; response.json())&#10;      .then(data =&gt; {&#10;        if (data.error) {&#10;          window.opener?.postMessage({&#10;            type: 'GOOGLE_AUTH_ERROR',&#10;            error: data.error&#10;          }, window.location.origin);&#10;        } else {&#10;          // 성공적으로 토큰을 받았을 때&#10;          window.opener?.postMessage({&#10;            type: 'GOOGLE_AUTH_SUCCESS',&#10;            accessToken: data.access_token,&#10;            refreshToken: data.refresh_token,&#10;            expiresAt: Date.now() + (data.expires_in * 1000),&#10;            userId: data.user_id,&#10;            displayName: data.display_name&#10;          }, window.location.origin);&#10;        }&#10;        window.close();&#10;      })&#10;      .catch(error =&gt; {&#10;        console.error('Token exchange error:', error);&#10;        window.opener?.postMessage({&#10;          type: 'GOOGLE_AUTH_ERROR',&#10;          error: 'Token exchange failed'&#10;        }, window.location.origin);&#10;        window.close();&#10;      });&#10;    }&#10;  }, [searchParams]);&#10;&#10;  return (&#10;    &lt;div className=&quot;flex items-center justify-center min-h-screen&quot;&gt;&#10;      &lt;div className=&quot;text-center&quot;&gt;&#10;        &lt;h2 className=&quot;text-lg font-semibold mb-2&quot;&gt;Google Drive 인증 중...&lt;/h2&gt;&#10;        &lt;p className=&quot;text-zinc-600&quot;&gt;잠시만 기다려주세요.&lt;/p&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;export default function GoogleCallbackPage() {&#10;  return (&#10;    &lt;Suspense fallback={&#10;      &lt;div className=&quot;flex items-center justify-center min-h-screen&quot;&gt;&#10;        &lt;div className=&quot;text-center&quot;&gt;&#10;          &lt;h2 className=&quot;text-lg font-semibold mb-2&quot;&gt;로딩 중...&lt;/h2&gt;&#10;          &lt;p className=&quot;text-zinc-600&quot;&gt;잠시만 기다려주세요.&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    }&gt;&#10;      &lt;GoogleCallbackContent /&gt;&#10;    &lt;/Suspense&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#13;&#10;&#13;&#10;import { useEffect, Suspense } from 'react';&#13;&#10;import { useSearchParams } from 'next/navigation';&#13;&#10;&#13;&#10;function GoogleCallbackContent() {&#13;&#10;  const searchParams = useSearchParams();&#13;&#10;&#13;&#10;  useEffect(() =&gt; {&#13;&#10;    const code = searchParams.get('code');&#13;&#10;    const error = searchParams.get('error');&#13;&#10;&#13;&#10;    // 부모 창의 origin을 가져오는 안전한 방법&#13;&#10;    const getParentOrigin = () =&gt; {&#13;&#10;      try {&#13;&#10;        return window.opener?.location.origin || '*';&#13;&#10;      } catch (e) {&#13;&#10;        // Cross-origin 접근 불가 시 와일드카드 사용&#13;&#10;        return '*';&#13;&#10;      }&#13;&#10;    };&#13;&#10;&#13;&#10;    if (error) {&#13;&#10;      // OAuth 에러 처리&#13;&#10;      const targetOrigin = getParentOrigin();&#13;&#10;      window.opener?.postMessage({&#13;&#10;        type: 'GOOGLE_AUTH_ERROR',&#13;&#10;        error: error&#13;&#10;      }, targetOrigin);&#13;&#10;      window.close();&#13;&#10;      return;&#13;&#10;    }&#13;&#10;&#13;&#10;    if (code) {&#13;&#10;      // Authorization code를 access token으로 교환&#13;&#10;      fetch('/api/auth/google/token', {&#13;&#10;        method: 'POST',&#13;&#10;        headers: {&#13;&#10;          'Content-Type': 'application/json'&#13;&#10;        },&#13;&#10;        body: JSON.stringify({ code })&#13;&#10;      })&#13;&#10;      .then(response =&gt; response.json())&#13;&#10;      .then(data =&gt; {&#13;&#10;        const targetOrigin = getParentOrigin();&#13;&#10;        &#13;&#10;        if (data.error) {&#13;&#10;          window.opener?.postMessage({&#13;&#10;            type: 'GOOGLE_AUTH_ERROR',&#13;&#10;            error: data.error&#13;&#10;          }, targetOrigin);&#13;&#10;        } else {&#13;&#10;          // 성공적으로 토큰을 받았을 때&#13;&#10;          window.opener?.postMessage({&#13;&#10;            type: 'GOOGLE_AUTH_SUCCESS',&#13;&#10;            accessToken: data.access_token,&#13;&#10;            refreshToken: data.refresh_token,&#13;&#10;            expiresAt: Date.now() + (data.expires_in * 1000),&#13;&#10;            userId: data.user_id,&#13;&#10;            displayName: data.display_name&#13;&#10;          }, targetOrigin);&#13;&#10;        }&#13;&#10;        window.close();&#13;&#10;      })&#13;&#10;      .catch(error =&gt; {&#13;&#10;        console.error('Token exchange error:', error);&#13;&#10;        const targetOrigin = getParentOrigin();&#13;&#10;        window.opener?.postMessage({&#13;&#10;          type: 'GOOGLE_AUTH_ERROR',&#13;&#10;          error: 'Token exchange failed'&#13;&#10;        }, targetOrigin);&#13;&#10;        window.close();&#13;&#10;      });&#13;&#10;    }&#13;&#10;  }, [searchParams]);&#13;&#10;&#13;&#10;  return (&#13;&#10;    &lt;div className=&quot;flex items-center justify-center min-h-screen&quot;&gt;&#13;&#10;      &lt;div className=&quot;text-center&quot;&gt;&#13;&#10;        &lt;h2 className=&quot;text-lg font-semibold mb-2&quot;&gt;Google Drive 인증 중...&lt;/h2&gt;&#13;&#10;        &lt;p className=&quot;text-zinc-600&quot;&gt;잠시만 기다려주세요.&lt;/p&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    &lt;/div&gt;&#13;&#10;  );&#13;&#10;}&#13;&#10;&#13;&#10;export default function GoogleCallbackPage() {&#13;&#10;  return (&#13;&#10;    &lt;Suspense fallback={&#13;&#10;      &lt;div className=&quot;flex items-center justify-center min-h-screen&quot;&gt;&#13;&#10;        &lt;div className=&quot;text-center&quot;&gt;&#13;&#10;          &lt;h2 className=&quot;text-lg font-semibold mb-2&quot;&gt;로딩 중...&lt;/h2&gt;&#13;&#10;          &lt;p className=&quot;text-zinc-600&quot;&gt;잠시만 기다려주세요.&lt;/p&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    }&gt;&#13;&#10;      &lt;GoogleCallbackContent /&gt;&#13;&#10;    &lt;/Suspense&gt;&#13;&#10;  );&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/layout.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/layout.tsx" />
              <option name="originalContent" value="import type { Metadata } from &quot;next&quot;;&#10;import { Inter } from &quot;next/font/google&quot;;&#10;import &quot;./globals.css&quot;;&#10;import { Toaster } from &quot;sonner&quot;;&#10;&#10;const inter = Inter({ subsets: [&quot;latin&quot;] });&#10;&#10;export const metadata: Metadata = {&#10;  title: &quot;My KALLAX is Full&quot;,&#10;  description: &quot;Generated by create next app&quot;,&#10;};&#10;&#10;export default function RootLayout({&#10;  children,&#10;}: Readonly&lt;{&#10;  children: React.ReactNode;&#10;}&gt;) {&#10;  return (&#10;    &lt;html lang=&quot;en&quot;&gt;&#10;      &lt;body className={inter.className}&gt;&#10;        {children}&#10;        &lt;Toaster /&gt;&#10;      &lt;/body&gt;&#10;    &lt;/html&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import type { Metadata } from &quot;next&quot;;&#10;import { Inter } from &quot;next/font/google&quot;;&#10;import &quot;./globals.css&quot;;&#10;import { Toaster } from &quot;sonner&quot;;&#10;import { ErrorBoundary } from &quot;@/components/error-boundary&quot;;&#10;&#10;const inter = Inter({ subsets: [&quot;latin&quot;] });&#10;&#10;export const metadata: Metadata = {&#10;  title: &quot;My KALLAX is Full&quot;,&#10;  description: &quot;나만의 앨범 컬렉션을 관리할 수 있는 웹 애플리케이션&quot;,&#10;};&#10;&#10;export default function RootLayout({&#10;  children,&#10;}: Readonly&lt;{&#10;  children: React.ReactNode;&#10;}&gt;) {&#10;  return (&#10;    &lt;html lang=&quot;ko&quot;&gt;&#10;      &lt;body className={inter.className}&gt;&#10;        &lt;ErrorBoundary&gt;&#10;          {children}&#10;        &lt;/ErrorBoundary&gt;&#10;        &lt;Toaster /&gt;&#10;      &lt;/body&gt;&#10;    &lt;/html&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/__tests__/album-card.test.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/__tests__/album-card.test.tsx" />
              <option name="originalContent" value="import { render, screen, fireEvent, waitFor } from '@testing-library/react';&#10;import { AlbumCard } from '../album-card';&#10;import type { Album } from '@/types/album';&#10;&#10;// Mock Next.js Image component&#10;jest.mock('next/image', () =&gt; {&#10;  return function MockImage(props: any) {&#10;    return &lt;img {...props} /&gt;;&#10;  };&#10;});&#10;&#10;// Mock album images utility&#10;jest.mock('@/lib/album-images', () =&gt; ({&#10;  getPrimaryCoverImage: jest.fn(),&#10;}));&#10;&#10;const mockAlbum: Album = {&#10;  id: '1',&#10;  artist: 'Test Artist',&#10;  title: 'Test Album',&#10;  type: 'Vinyl',&#10;  isFavorite: false,&#10;  createdAt: '2024-01-01T00:00:00Z',&#10;  updatedAt: '2024-01-01T00:00:00Z',&#10;  releaseDate: '2024',&#10;  coverImageUrl: 'https://example.com/cover.jpg',&#10;};&#10;&#10;const mockFavoriteAlbum: Album = {&#10;  ...mockAlbum,&#10;  id: '2',&#10;  isFavorite: true,&#10;};&#10;&#10;describe('AlbumCard', () =&gt; {&#10;  const mockOnClick = jest.fn();&#10;  const mockOnDelete = jest.fn();&#10;&#10;  beforeEach(() =&gt; {&#10;    jest.clearAllMocks();&#10;    require('@/lib/album-images').getPrimaryCoverImage.mockReturnValue('https://example.com/cover.jpg');&#10;  });&#10;&#10;  it('renders album information correctly', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    expect(screen.getByText('Test Artist')).toBeInTheDocument();&#10;    expect(screen.getByText('Test Album')).toBeInTheDocument();&#10;    expect(screen.getByText('2024')).toBeInTheDocument();&#10;  });&#10;&#10;  it('shows favorite star for favorite albums', () =&gt; {&#10;    render(&lt;AlbumCard album={mockFavoriteAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const starIcon = screen.getByRole('button', { name: /test album 상세 보기/i }).querySelector('svg');&#10;    expect(starIcon).toBeInTheDocument();&#10;  });&#10;&#10;  it('does not show favorite star for non-favorite albums', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const cardButton = screen.getByRole('button', { name: /test album 상세 보기/i });&#10;    const starIcon = cardButton.querySelector('.text-yellow-400');&#10;    expect(starIcon).not.toBeInTheDocument();&#10;  });&#10;&#10;  it('calls onClick when card is clicked', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const card = screen.getByRole('button', { name: /test album 상세 보기/i });&#10;    fireEvent.click(card);&#10;&#10;    expect(mockOnClick).toHaveBeenCalledWith();&#10;  });&#10;&#10;  it('calls onClick when Enter key is pressed', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const card = screen.getByRole('button', { name: /test album 상세 보기/i });&#10;    fireEvent.keyDown(card, { key: 'Enter' });&#10;&#10;    expect(mockOnClick).toHaveBeenCalledWith();&#10;  });&#10;&#10;  it('calls onClick when Space key is pressed', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const card = screen.getByRole('button', { name: /test album 상세 보기/i });&#10;    fireEvent.keyDown(card, { key: ' ' });&#10;&#10;    expect(mockOnClick).toHaveBeenCalledWith();&#10;  });&#10;&#10;  it('calls onDelete when delete button is clicked', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const deleteButton = screen.getByRole('button', { name: /앨범 삭제/i });&#10;    fireEvent.click(deleteButton);&#10;&#10;    expect(mockOnDelete).toHaveBeenCalledWith();&#10;    expect(mockOnClick).not.toHaveBeenCalled(); // Should not trigger card click&#10;  });&#10;&#10;  it('shows loading state for images', async () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    // Initially should show loading state (pulse animation)&#10;    const imageContainer = screen.getByText('Test Album').closest('.min-h-\\[200px\\]');&#10;    expect(imageContainer).toBeInTheDocument();&#10;  });&#10;&#10;  it('shows &quot;No Image&quot; when no cover image is available', () =&gt; {&#10;    require('@/lib/album-images').getPrimaryCoverImage.mockReturnValue(null);&#10;&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    expect(screen.getByText('No Image')).toBeInTheDocument();&#10;  });&#10;&#10;  it('handles image loading error gracefully', async () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const image = screen.getByAltText('Test Album');&#10;    fireEvent.error(image);&#10;&#10;    await waitFor(() =&gt; {&#10;      expect(screen.getByText('No Image')).toBeInTheDocument();&#10;    });&#10;  });&#10;&#10;  it('has proper accessibility attributes', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const card = screen.getByRole('button', { name: /test album 상세 보기/i });&#10;    expect(card).toHaveAttribute('tabIndex', '0');&#10;    expect(card).toHaveAttribute('aria-label', 'Test Album 상세 보기');&#10;&#10;    const deleteButton = screen.getByRole('button', { name: /앨범 삭제/i });&#10;    expect(deleteButton).toHaveAttribute('aria-label', '앨범 삭제');&#10;    expect(deleteButton).toHaveAttribute('tabIndex', '0');&#10;  });&#10;&#10;  it('shows title and artist with proper truncation', () =&gt; {&#10;    const longTitleAlbum: Album = {&#10;      ...mockAlbum,&#10;      title: 'This is a very long album title that should be truncated',&#10;      artist: 'This is a very long artist name that should also be truncated',&#10;    };&#10;&#10;    render(&lt;AlbumCard album={longTitleAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const titleElement = screen.getByText(longTitleAlbum.title);&#10;    const artistElement = screen.getByText(longTitleAlbum.artist);&#10;&#10;    expect(titleElement).toHaveClass('truncate');&#10;    expect(artistElement).toHaveClass('truncate');&#10;    expect(titleElement).toHaveAttribute('title', longTitleAlbum.title);&#10;    expect(artistElement).toHaveAttribute('title', longTitleAlbum.artist);&#10;  });&#10;});&#10;" />
              <option name="updatedContent" value="import { render, screen, fireEvent, waitFor } from '@testing-library/react';&#10;import { AlbumCard } from '../album-card';&#10;import type { Album } from '@/types/album';&#10;import { getPrimaryCoverImage } from '@/lib/album-images';&#10;&#10;// Mock Next.js Image component&#10;jest.mock('next/image', () =&gt; {&#10;  return function MockImage(props: React.ImgHTMLAttributes&lt;HTMLImageElement&gt;) {&#10;    // eslint-disable-next-line @next/next/no-img-element, jsx-a11y/alt-text&#10;    return &lt;img {...props} data-testid=&quot;mock-image&quot; /&gt;;&#10;  };&#10;});&#10;&#10;// Mock album images utility&#10;jest.mock('@/lib/album-images', () =&gt; ({&#10;  getPrimaryCoverImage: jest.fn(),&#10;}));&#10;&#10;const mockGetPrimaryCoverImage = getPrimaryCoverImage as jest.MockedFunction&lt;typeof getPrimaryCoverImage&gt;;&#10;&#10;const mockAlbum: Album = {&#10;  id: '1',&#10;  artist: 'Test Artist',&#10;  title: 'Test Album',&#10;  type: 'Vinyl',&#10;  isFavorite: false,&#10;  createdAt: '2024-01-01T00:00:00Z',&#10;  updatedAt: '2024-01-01T00:00:00Z',&#10;  releaseDate: '2024',&#10;  coverImageUrl: 'https://example.com/cover.jpg',&#10;};&#10;&#10;const mockFavoriteAlbum: Album = {&#10;  ...mockAlbum,&#10;  id: '2',&#10;  isFavorite: true,&#10;};&#10;&#10;describe('AlbumCard', () =&gt; {&#10;  const mockOnClick = jest.fn();&#10;  const mockOnDelete = jest.fn();&#10;&#10;  beforeEach(() =&gt; {&#10;    jest.clearAllMocks();&#10;    mockGetPrimaryCoverImage.mockReturnValue('https://example.com/cover.jpg');&#10;  });&#10;&#10;  it('renders album information correctly', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    expect(screen.getByText('Test Artist')).toBeInTheDocument();&#10;    expect(screen.getByText('Test Album')).toBeInTheDocument();&#10;    expect(screen.getByText('2024')).toBeInTheDocument();&#10;  });&#10;&#10;  it('shows favorite star for favorite albums', () =&gt; {&#10;    render(&lt;AlbumCard album={mockFavoriteAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const starIcon = screen.getByRole('button', { name: /test album 상세 보기/i }).querySelector('svg');&#10;    expect(starIcon).toBeInTheDocument();&#10;  });&#10;&#10;  it('does not show favorite star for non-favorite albums', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const cardButton = screen.getByRole('button', { name: /test album 상세 보기/i });&#10;    const starIcon = cardButton.querySelector('.text-yellow-400');&#10;    expect(starIcon).not.toBeInTheDocument();&#10;  });&#10;&#10;  it('calls onClick when card is clicked', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const card = screen.getByRole('button', { name: /test album 상세 보기/i });&#10;    fireEvent.click(card);&#10;&#10;    expect(mockOnClick).toHaveBeenCalledWith();&#10;  });&#10;&#10;  it('calls onClick when Enter key is pressed', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const card = screen.getByRole('button', { name: /test album 상세 보기/i });&#10;    fireEvent.keyDown(card, { key: 'Enter' });&#10;&#10;    expect(mockOnClick).toHaveBeenCalledWith();&#10;  });&#10;&#10;  it('calls onClick when Space key is pressed', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const card = screen.getByRole('button', { name: /test album 상세 보기/i });&#10;    fireEvent.keyDown(card, { key: ' ' });&#10;&#10;    expect(mockOnClick).toHaveBeenCalledWith();&#10;  });&#10;&#10;  it('calls onDelete when delete button is clicked', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const deleteButton = screen.getByRole('button', { name: /앨범 삭제/i });&#10;    fireEvent.click(deleteButton);&#10;&#10;    expect(mockOnDelete).toHaveBeenCalledWith();&#10;    expect(mockOnClick).not.toHaveBeenCalled(); // Should not trigger card click&#10;  });&#10;&#10;  it('shows loading state for images', async () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    // Initially should show loading state (pulse animation)&#10;    const imageContainer = screen.getByText('Test Album').closest('.min-h-\\[200px\\]');&#10;    expect(imageContainer).toBeInTheDocument();&#10;  });&#10;&#10;  it('shows &quot;No Image&quot; when no cover image is available', () =&gt; {&#10;    mockGetPrimaryCoverImage.mockReturnValue(null);&#10;    &#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    expect(screen.getByText('No Image')).toBeInTheDocument();&#10;  });&#10;&#10;  it('handles image loading error gracefully', async () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const image = screen.getByAltText('Test Album');&#10;    fireEvent.error(image);&#10;&#10;    await waitFor(() =&gt; {&#10;      expect(screen.getByText('No Image')).toBeInTheDocument();&#10;    });&#10;  });&#10;&#10;  it('has proper accessibility attributes', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const card = screen.getByRole('button', { name: /test album 상세 보기/i });&#10;    expect(card).toHaveAttribute('tabIndex', '0');&#10;    expect(card).toHaveAttribute('aria-label', 'Test Album 상세 보기');&#10;&#10;    const deleteButton = screen.getByRole('button', { name: /앨범 삭제/i });&#10;    expect(deleteButton).toHaveAttribute('aria-label', '앨범 삭제');&#10;    expect(deleteButton).toHaveAttribute('tabIndex', '0');&#10;  });&#10;&#10;  it('shows title and artist with proper truncation', () =&gt; {&#10;    const longTitleAlbum: Album = {&#10;      ...mockAlbum,&#10;      title: 'This is a very long album title that should be truncated',&#10;      artist: 'This is a very long artist name that should also be truncated',&#10;    };&#10;&#10;    render(&lt;AlbumCard album={longTitleAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const titleElement = screen.getByText(longTitleAlbum.title);&#10;    const artistElement = screen.getByText(longTitleAlbum.artist);&#10;&#10;    expect(titleElement).toHaveClass('truncate');&#10;    expect(artistElement).toHaveClass('truncate');&#10;    expect(titleElement).toHaveAttribute('title', longTitleAlbum.title);&#10;    expect(artistElement).toHaveAttribute('title', longTitleAlbum.artist);&#10;  });&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/album-card.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/album-card.tsx" />
              <option name="originalContent" value="import * as React from &quot;react&quot;;&#10;import type { Album } from &quot;@/types/album&quot;;&#10;import { Star, Trash2 } from &quot;lucide-react&quot;;&#10;import Image from 'next/image';&#10;import { getPrimaryCoverImage } from &quot;@/lib/album-images&quot;;&#10;&#10;interface AlbumCardProps {&#10;  album: Album;&#10;  onClick?: () =&gt; void;&#10;  onDelete?: () =&gt; void;&#10;  onEdit?: () =&gt; void;&#10;}&#10;&#10;export function AlbumCard({ album, onClick, onDelete }: AlbumCardProps) {&#10;  const primaryImageUrl = getPrimaryCoverImage(album);&#10;&#10;  return (&#10;    &lt;div&#10;      className=&quot;relative bg-white dark:bg-zinc-900 rounded-lg shadow p-4 flex flex-col items-center gap-2 border border-zinc-200 dark:border-zinc-800 cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-2xl focus:outline-none focus:ring-2 focus:ring-blue-400 hover:opacity-95 min-h-[200px]&quot;&#10;      onClick={onClick}&#10;      tabIndex={0}&#10;      role=&quot;button&quot;&#10;      aria-label={`${album.title} 상세 보기`}&#10;      onKeyDown={e =&gt; { if (e.key === 'Enter' || e.key === ' ') onClick?.(); }}&#10;    &gt;&#10;      &lt;button&#10;        className=&quot;absolute top-2 left-2 text-zinc-400 hover:text-red-500 z-10 bg-white/80 dark:bg-zinc-900/80 rounded-full p-1&quot;&#10;        onClick={e =&gt; { e.stopPropagation(); onDelete?.(); }}&#10;        aria-label=&quot;앨범 삭제&quot;&#10;        tabIndex={0}&#10;      &gt;&#10;        &lt;Trash2 className=&quot;w-5 h-5&quot; /&gt;&#10;      &lt;/button&gt;&#10;      &lt;div className=&quot;w-32 h-32 bg-zinc-100 dark:bg-zinc-800 rounded overflow-hidden flex items-center justify-center&quot;&gt;&#10;        {primaryImageUrl ? (&#10;          &lt;Image&#10;            src={primaryImageUrl}&#10;            alt={album.title}&#10;            width={128}&#10;            height={128}&#10;            style={{ objectFit: 'cover' }}&#10;        /&gt;&#10;        ) : (&#10;          &lt;span className=&quot;text-zinc-400&quot;&gt;No Image&lt;/span&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;      &lt;div className=&quot;flex flex-col items-center w-full&quot;&gt;&#10;        &lt;span className=&quot;font-semibold text-base w-full text-center truncate&quot; title={album.title}&gt;{album.title}&lt;/span&gt;&#10;        &lt;span className=&quot;text-sm text-zinc-500 w-full text-center truncate&quot; title={album.artist}&gt;{album.artist}&lt;/span&gt;&#10;        {album.releaseDate &amp;&amp; (&#10;          &lt;span className=&quot;text-xs text-zinc-400&quot;&gt;{album.releaseDate}&lt;/span&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;      {album.isFavorite &amp;&amp; (&#10;        &lt;Star className=&quot;absolute top-2 right-2 text-yellow-400 fill-yellow-400 w-5 h-5&quot; /&gt;&#10;      )}&#10;    &lt;/div&gt;&#10;  );&#10;} " />
              <option name="updatedContent" value="import * as React from &quot;react&quot;;&#10;import type { Album } from &quot;@/types/album&quot;;&#10;import { Star, Trash2 } from &quot;lucide-react&quot;;&#10;import Image from 'next/image';&#10;import { getPrimaryCoverImage } from &quot;@/lib/album-images&quot;;&#10;&#10;interface AlbumCardProps {&#10;  album: Album;&#10;  onClick?: () =&gt; void;&#10;  onDelete?: () =&gt; void;&#10;  onEdit?: () =&gt; void;&#10;}&#10;&#10;export function AlbumCard({ album, onClick, onDelete }: AlbumCardProps) {&#10;  const primaryImageUrl = getPrimaryCoverImage(album);&#10;  const [imageError, setImageError] = React.useState(false);&#10;  const [imageLoading, setImageLoading] = React.useState(true);&#10;&#10;  const handleImageLoad = () =&gt; {&#10;    setImageLoading(false);&#10;  };&#10;&#10;  const handleImageError = () =&gt; {&#10;    setImageError(true);&#10;    setImageLoading(false);&#10;  };&#10;&#10;  return (&#10;    &lt;div&#10;      className=&quot;relative bg-white dark:bg-zinc-900 rounded-lg shadow p-4 flex flex-col items-center gap-2 border border-zinc-200 dark:border-zinc-800 cursor-pointer transition-all duration-200 ease-in-out hover:scale-105 hover:shadow-2xl focus:outline-none focus:ring-2 focus:ring-blue-400 hover:opacity-95 min-h-[200px]&quot;&#10;      onClick={onClick}&#10;      tabIndex={0}&#10;      role=&quot;button&quot;&#10;      aria-label={`${album.title} 상세 보기`}&#10;      onKeyDown={e =&gt; { if (e.key === 'Enter' || e.key === ' ') onClick?.(); }}&#10;    &gt;&#10;      &lt;button&#10;        className=&quot;absolute top-2 left-2 text-zinc-400 hover:text-red-500 z-10 bg-white/80 dark:bg-zinc-900/80 rounded-full p-1&quot;&#10;        onClick={e =&gt; { e.stopPropagation(); onDelete?.(); }}&#10;        aria-label=&quot;앨범 삭제&quot;&#10;        tabIndex={0}&#10;      &gt;&#10;        &lt;Trash2 className=&quot;w-5 h-5&quot; /&gt;&#10;      &lt;/button&gt;&#10;      &#10;      &lt;div className=&quot;w-32 h-32 bg-zinc-100 dark:bg-zinc-800 rounded overflow-hidden flex items-center justify-center relative&quot;&gt;&#10;        {primaryImageUrl &amp;&amp; !imageError ? (&#10;          &lt;&gt;&#10;            {imageLoading &amp;&amp; (&#10;              &lt;div className=&quot;absolute inset-0 bg-zinc-100 dark:bg-zinc-800 animate-pulse rounded&quot; /&gt;&#10;            )}&#10;            &lt;Image&#10;              src={primaryImageUrl}&#10;              alt={album.title}&#10;              width={128}&#10;              height={128}&#10;              className={`transition-opacity duration-300 ${imageLoading ? 'opacity-0' : 'opacity-100'}`}&#10;              style={{ objectFit: 'cover' }}&#10;              onLoad={handleImageLoad}&#10;              onError={handleImageError}&#10;              loading=&quot;lazy&quot;&#10;              placeholder=&quot;blur&quot;&#10;              blurDataURL=&quot;data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAhEAACAQMDBQAAAAAAAAAAAAABAgMABAUGIWGRkqGx0f/EABUBAQEAAAAAAAAAAAAAAAAAAAMF/8QAGhEAAgIDAAAAAAAAAAAAAAAAAAECEgMRkf/aAAwDAQACEQMRAD8AltJagyeH0AthI5xdrLcNM91BF5pX2HaH9bcfaSXWGaRmknyJckliyjqTzSlT54b6bk+h0R+Rq5xDGuJ4O2yl+odzqd2qjvz/2Q==&quot;&#10;            /&gt;&#10;          &lt;/&gt;&#10;        ) : (&#10;          &lt;span className=&quot;text-zinc-400 text-sm&quot;&gt;No Image&lt;/span&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;      &#10;      &lt;div className=&quot;flex flex-col items-center w-full&quot;&gt;&#10;        &lt;span className=&quot;font-semibold text-base w-full text-center truncate&quot; title={album.title}&gt;{album.title}&lt;/span&gt;&#10;        &lt;span className=&quot;text-sm text-zinc-500 w-full text-center truncate&quot; title={album.artist}&gt;{album.artist}&lt;/span&gt;&#10;        {album.releaseDate &amp;&amp; (&#10;          &lt;span className=&quot;text-xs text-zinc-400&quot;&gt;{album.releaseDate}&lt;/span&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;      {album.isFavorite &amp;&amp; (&#10;        &lt;Star className=&quot;absolute top-2 right-2 text-yellow-400 fill-yellow-400 w-5 h-5&quot; /&gt;&#10;      )}&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/album-grid.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/album-grid.tsx" />
              <option name="originalContent" value="import * as React from &quot;react&quot;;&#10;import type { Album } from &quot;@/types/album&quot;;&#10;import { AlbumCard } from &quot;@/components/album-card&quot;;&#10;&#10;interface AlbumGridProps {&#10;  albums: Album[];&#10;  onAlbumClick?: (album: Album) =&gt; void;&#10;  onEditAlbum?: (album: Album) =&gt; void;&#10;  onDeleteAlbum?: (album: Album) =&gt; void;&#10;}&#10;&#10;export function AlbumGrid({ albums, onAlbumClick, onEditAlbum, onDeleteAlbum }: AlbumGridProps) {&#10;  if (albums.length === 0) {&#10;    return &lt;div className=&quot;text-zinc-400 text-center py-8&quot;&gt;등록된 앨범이 없습니다.&lt;/div&gt;;&#10;  }&#10;  return (&#10;    &lt;div className=&quot;grid grid-cols-1 xs:grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-3 sm:gap-4 md:gap-6 w-full&quot;&gt;&#10;      {albums.map((album) =&gt; (&#10;        &lt;AlbumCard&#10;          key={album.id}&#10;          album={album}&#10;          onClick={() =&gt; onAlbumClick?.(album)}&#10;          onDelete={() =&gt; onDeleteAlbum?.(album)}&#10;          onEdit={() =&gt; onEditAlbum?.(album)}&#10;        /&gt;&#10;      ))}&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="// 기존 album-grid.tsx를 가상화된 버전으로 교체&#10;export { AlbumGrid, VirtualizedAlbumGrid } from './virtualized-album-grid';" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/create-collection-modal.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/create-collection-modal.tsx" />
              <option name="originalContent" value="import React, { useState } from 'react';&#10;import { useModalAccessibility } from '@/lib/useModalAccessibility';&#10;import { Button } from '@/components/ui/button';&#10;import { Input } from '@/components/ui/input';&#10;import { Label } from '@/components/ui/label';&#10;import { X } from 'lucide-react';&#10;import { toast } from 'sonner';&#10;import { createNewFileHandle, setCollectionMetadata, setLastOpenedCollection, setActiveFileHandle } from '@/lib/db';&#10;&#10;interface CreateCollectionModalProps {&#10;  onClose: () =&gt; void;&#10;  onCollectionCreated: (username: string, collectionName: string) =&gt; void;&#10;  initialUsername?: string; // Make it optional&#10;}&#10;&#10;export function CreateCollectionModal({&#10;  onClose,&#10;  onCollectionCreated,&#10;  initialUsername = '', // Provide a default value&#10;}: CreateCollectionModalProps) {&#10;  const modalRef = useModalAccessibility(onClose);&#10;  const [username, setUsername] = useState(initialUsername);&#10;  const [collectionName, setCollectionName] = useState('');&#10;  const [isLoading, setIsLoading] = useState(false);&#10;&#10;  const handleCreate = async (e: React.FormEvent) =&gt; {&#10;    e.preventDefault();&#10;    if (!username.trim() || !collectionName.trim()) {&#10;      toast.error(&quot;사용자명과 컬렉션 이름을 입력해주세요.&quot;);&#10;      return;&#10;    }&#10;&#10;    setIsLoading(true);&#10;    try {&#10;      const fileHandle = await createNewFileHandle(`${collectionName}.json`);&#10;      if (!fileHandle) {&#10;        toast.info(&quot;컬렉션 생성이 취소되었습니다.&quot;);&#10;        return;&#10;      }&#10;&#10;      const initialContent = JSON.stringify({ _metadata: { username: username, collectionName: collectionName }, albums: [] }, null, 2);&#10;      const writable = await fileHandle.createWritable();&#10;      await writable.write(initialContent);&#10;      await writable.close();&#10;&#10;      await setCollectionMetadata(username, collectionName, 0);&#10;      await setActiveFileHandle(fileHandle);&#10;      await setLastOpenedCollection(username, collectionName);&#10;      onCollectionCreated(username, collectionName);&#10;    } catch (error) {&#10;      console.error(&quot;컬렉션 생성 실패:&quot;, error);&#10;      toast.error(&quot;컬렉션 생성에 실패했습니다.&quot;);&#10;    } finally {&#10;      setIsLoading(false);&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;fixed inset-0 bg-black/40 flex items-center justify-center z-50 animate-fadein&quot;&gt;&#10;      &lt;div&#10;        className=&quot;relative bg-white dark:bg-zinc-900 rounded-xl shadow-xl p-6 w-full max-w-md border border-zinc-200 dark:border-zinc-800&quot;&#10;        ref={modalRef}&#10;      &gt;&#10;        &lt;h2 className=&quot;text-2xl font-bold mb-4&quot;&gt;새 컬렉션 생성&lt;/h2&gt;&#10;        &lt;button&#10;          className=&quot;absolute top-3 right-3 text-zinc-500 hover:text-zinc-800 dark:hover:text-zinc-200 transition-colors&quot;&#10;          onClick={onClose}&#10;          aria-label=&quot;닫기&quot;&#10;        &gt;&#10;          &lt;X className=&quot;w-6 h-6&quot; /&gt;&#10;        &lt;/button&gt;&#10;&#10;        &lt;form onSubmit={handleCreate} className=&quot;space-y-4&quot;&gt;&#10;          &lt;div&gt;&#10;            &lt;Label htmlFor=&quot;new-username&quot;&gt;사용자명&lt;/Label&gt;&#10;            &lt;Input&#10;              id=&quot;new-username&quot;&#10;              type=&quot;text&quot;&#10;              value={username}&#10;              onChange={(e) =&gt; setUsername(e.target.value)}&#10;              placeholder=&quot;사용자명&quot;&#10;              required&#10;              disabled={isLoading}&#10;            /&gt;&#10;          &lt;/div&gt;&#10;          &lt;div&gt;&#10;            &lt;Label htmlFor=&quot;new-collection-name&quot;&gt;컬렉션 이름&lt;/Label&gt;&#10;            &lt;Input&#10;              id=&quot;new-collection-name&quot;&#10;              type=&quot;text&quot;&#10;              value={collectionName}&#10;              onChange={(e) =&gt; setCollectionName(e.target.value)}&#10;              placeholder=&quot;새 컬렉션 이름&quot;&#10;              required&#10;              disabled={isLoading}&#10;            /&gt;&#10;          &lt;/div&gt;&#10;          &lt;Button type=&quot;submit&quot; className=&quot;w-full&quot; disabled={isLoading}&gt;&#10;            {isLoading ? &quot;생성 중...&quot; : &quot;컬렉션 생성&quot;}&#10;          &lt;/Button&gt;&#10;        &lt;/form&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import React, { useState } from 'react';&#10;import { useModalAccessibility } from '@/lib/useModalAccessibility';&#10;import { useFileOperation } from '@/lib/useAsyncState';&#10;import { Button } from '@/components/ui/button';&#10;import { Input } from '@/components/ui/input';&#10;import { Label } from '@/components/ui/label';&#10;import { X } from 'lucide-react';&#10;import { toast } from 'sonner';&#10;import { createNewFileHandle, setCollectionMetadata, setLastOpenedCollection, setActiveFileHandle } from '@/lib/db';&#10;&#10;interface CreateCollectionModalProps {&#10;  onClose: () =&gt; void;&#10;  onCollectionCreated: (username: string, collectionName: string) =&gt; void;&#10;  initialUsername?: string; // Make it optional&#10;}&#10;&#10;export function CreateCollectionModal({&#10;  onClose,&#10;  onCollectionCreated,&#10;  initialUsername = '', // Provide a default value&#10;}: CreateCollectionModalProps) {&#10;  const modalRef = useModalAccessibility(onClose);&#10;  const [username, setUsername] = useState(initialUsername);&#10;  const [collectionName, setCollectionName] = useState('');&#10;  const { isLoading, execute } = useFileOperation();&#10;&#10;  const handleCreate = async (e: React.FormEvent) =&gt; {&#10;    e.preventDefault();&#10;    if (!username.trim() || !collectionName.trim()) {&#10;      toast.error(&quot;사용자명과 컬렉션 이름을 입력해주세요.&quot;);&#10;      return;&#10;    }&#10;&#10;    await execute(async () =&gt; {&#10;      const fileHandle = await createNewFileHandle(`${collectionName}.json`);&#10;      if (!fileHandle) {&#10;        toast.info(&quot;컬렉션 생성이 취소되었습니다.&quot;);&#10;        return { message: &quot;컬렉션 생성이 취소되었습니다.&quot; };&#10;      }&#10;&#10;      const initialContent = JSON.stringify({ _metadata: { username: username, collectionName: collectionName }, albums: [] }, null, 2);&#10;      const writable = await fileHandle.createWritable();&#10;      await writable.write(initialContent);&#10;      await writable.close();&#10;&#10;      await setCollectionMetadata(username, collectionName, 0);&#10;      await setActiveFileHandle(fileHandle);&#10;      await setLastOpenedCollection(username, collectionName);&#10;      onCollectionCreated(username, collectionName);&#10;      &#10;      return { message: &quot;컬렉션이 성공적으로 생성되었습니다.&quot; };&#10;    });&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;fixed inset-0 bg-black/40 flex items-center justify-center z-50 animate-fadein&quot;&gt;&#10;      &lt;div&#10;        className=&quot;relative bg-white dark:bg-zinc-900 rounded-xl shadow-xl p-6 w-full max-w-md border border-zinc-200 dark:border-zinc-800&quot;&#10;        ref={modalRef}&#10;      &gt;&#10;        &lt;h2 className=&quot;text-2xl font-bold mb-4&quot;&gt;새 컬렉션 생성&lt;/h2&gt;&#10;        &lt;button&#10;          className=&quot;absolute top-3 right-3 text-zinc-500 hover:text-zinc-800 dark:hover:text-zinc-200 transition-colors&quot;&#10;          onClick={onClose}&#10;          aria-label=&quot;닫기&quot;&#10;        &gt;&#10;          &lt;X className=&quot;w-6 h-6&quot; /&gt;&#10;        &lt;/button&gt;&#10;&#10;        &lt;form onSubmit={handleCreate} className=&quot;space-y-4&quot;&gt;&#10;          &lt;div&gt;&#10;            &lt;Label htmlFor=&quot;new-username&quot;&gt;사용자명&lt;/Label&gt;&#10;            &lt;Input&#10;              id=&quot;new-username&quot;&#10;              type=&quot;text&quot;&#10;              value={username}&#10;              onChange={(e) =&gt; setUsername(e.target.value)}&#10;              placeholder=&quot;사용자명&quot;&#10;              required&#10;              disabled={isLoading}&#10;            /&gt;&#10;          &lt;/div&gt;&#10;          &lt;div&gt;&#10;            &lt;Label htmlFor=&quot;new-collection-name&quot;&gt;컬렉션 이름&lt;/Label&gt;&#10;            &lt;Input&#10;              id=&quot;new-collection-name&quot;&#10;              type=&quot;text&quot;&#10;              value={collectionName}&#10;              onChange={(e) =&gt; setCollectionName(e.target.value)}&#10;              placeholder=&quot;새 컬렉션 이름&quot;&#10;              required&#10;              disabled={isLoading}&#10;            /&gt;&#10;          &lt;/div&gt;&#10;          &lt;Button type=&quot;submit&quot; className=&quot;w-full&quot; disabled={isLoading}&gt;&#10;            {isLoading ? &quot;생성 중...&quot; : &quot;컬렉션 생성&quot;}&#10;          &lt;/Button&gt;&#10;        &lt;/form&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/error-boundary.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/error-boundary.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;import React, { Component, ErrorInfo, ReactNode } from 'react';&#10;import { APIError } from '@/lib/error-handler';&#10;import { Button } from '@/components/ui/button';&#10;import { AlertTriangle, RefreshCw, Home } from 'lucide-react';&#10;&#10;interface Props {&#10;  children: ReactNode;&#10;  fallback?: ReactNode;&#10;  onError?: (error: Error, errorInfo: ErrorInfo) =&gt; void;&#10;}&#10;&#10;interface State {&#10;  hasError: boolean;&#10;  error: Error | null;&#10;  errorInfo: ErrorInfo | null;&#10;}&#10;&#10;export class ErrorBoundary extends Component&lt;Props, State&gt; {&#10;  constructor(props: Props) {&#10;    super(props);&#10;    this.state = { hasError: false, error: null, errorInfo: null };&#10;  }&#10;&#10;  static getDerivedStateFromError(error: Error): State {&#10;    return {&#10;      hasError: true,&#10;      error,&#10;      errorInfo: null,&#10;    };&#10;  }&#10;&#10;  componentDidCatch(error: Error, errorInfo: ErrorInfo) {&#10;    console.error('ErrorBoundary caught an error:', error, errorInfo);&#10;&#10;    this.setState({&#10;      error,&#10;      errorInfo,&#10;    });&#10;&#10;    // 사용자 정의 에러 핸들러 호출&#10;    if (this.props.onError) {&#10;      this.props.onError(error, errorInfo);&#10;    }&#10;&#10;    // 에러 로깅 (실제 서비스에서는 에러 리포팅 서비스로 전송)&#10;    this.logErrorToService(error, errorInfo);&#10;  }&#10;&#10;  private logErrorToService = (error: Error, errorInfo: ErrorInfo) =&gt; {&#10;    // 여기서 실제 에러 리포팅 서비스(Sentry, LogRocket 등)로 전송할 수 있습니다&#10;    console.log('Error logged:', {&#10;      error: error.message,&#10;      stack: error.stack,&#10;      componentStack: errorInfo.componentStack,&#10;      timestamp: new Date().toISOString(),&#10;    });&#10;  };&#10;&#10;  private handleReload = () =&gt; {&#10;    window.location.reload();&#10;  };&#10;&#10;  private handleGoHome = () =&gt; {&#10;    window.location.href = '/';&#10;  };&#10;&#10;  private handleRetry = () =&gt; {&#10;    this.setState({ hasError: false, error: null, errorInfo: null });&#10;  };&#10;&#10;  render() {&#10;    if (this.state.hasError) {&#10;      // 사용자 정의 fallback UI가 있으면 사용&#10;      if (this.props.fallback) {&#10;        return this.props.fallback;&#10;      }&#10;&#10;      // 기본 에러 UI&#10;      return (&#10;        &lt;div className=&quot;min-h-screen flex items-center justify-center bg-gray-50 dark:bg-zinc-900&quot;&gt;&#10;          &lt;div className=&quot;max-w-md w-full bg-white dark:bg-zinc-800 rounded-lg shadow-lg p-6 border border-gray-200 dark:border-zinc-700&quot;&gt;&#10;            &lt;div className=&quot;flex items-center justify-center w-12 h-12 mx-auto bg-red-100 dark:bg-red-900/20 rounded-full mb-4&quot;&gt;&#10;              &lt;AlertTriangle className=&quot;w-6 h-6 text-red-600 dark:text-red-400&quot; /&gt;&#10;            &lt;/div&gt;&#10;&#10;            &lt;h1 className=&quot;text-xl font-semibold text-gray-900 dark:text-gray-100 text-center mb-2&quot;&gt;&#10;              앗, 문제가 발생했습니다!&#10;            &lt;/h1&gt;&#10;&#10;            &lt;p className=&quot;text-gray-600 dark:text-gray-300 text-center mb-6&quot;&gt;&#10;              예상치 못한 오류가 발생했습니다. 페이지를 새로고침하거나 홈으로 돌아가 보세요.&#10;            &lt;/p&gt;&#10;&#10;            {/* 개발 환경에서만 에러 세부 정보 표시 */}&#10;            {process.env.NODE_ENV === 'development' &amp;&amp; this.state.error &amp;&amp; (&#10;              &lt;details className=&quot;mb-4 p-3 bg-gray-100 dark:bg-zinc-700 rounded text-sm&quot;&gt;&#10;                &lt;summary className=&quot;cursor-pointer font-medium text-gray-700 dark:text-gray-300&quot;&gt;&#10;                  에러 세부 정보 (개발 모드)&#10;                &lt;/summary&gt;&#10;                &lt;div className=&quot;mt-2 text-red-600 dark:text-red-400 font-mono text-xs whitespace-pre-wrap&quot;&gt;&#10;                  {this.state.error.message}&#10;                  {this.state.error.stack &amp;&amp; (&#10;                    &lt;div className=&quot;mt-2 opacity-75&quot;&gt;&#10;                      {this.state.error.stack}&#10;                    &lt;/div&gt;&#10;                  )}&#10;                &lt;/div&gt;&#10;              &lt;/details&gt;&#10;            )}&#10;&#10;            &lt;div className=&quot;flex flex-col sm:flex-row gap-3&quot;&gt;&#10;              &lt;Button&#10;                onClick={this.handleRetry}&#10;                className=&quot;flex-1 flex items-center justify-center gap-2&quot;&#10;                variant=&quot;outline&quot;&#10;              &gt;&#10;                &lt;RefreshCw className=&quot;w-4 h-4&quot; /&gt;&#10;                다시 시도&#10;              &lt;/Button&gt;&#10;&#10;              &lt;Button&#10;                onClick={this.handleReload}&#10;                className=&quot;flex-1 flex items-center justify-center gap-2&quot;&#10;                variant=&quot;outline&quot;&#10;              &gt;&#10;                &lt;RefreshCw className=&quot;w-4 h-4&quot; /&gt;&#10;                새로고침&#10;              &lt;/Button&gt;&#10;&#10;              &lt;Button&#10;                onClick={this.handleGoHome}&#10;                className=&quot;flex-1 flex items-center justify-center gap-2&quot;&#10;              &gt;&#10;                &lt;Home className=&quot;w-4 h-4&quot; /&gt;&#10;                홈으로&#10;              &lt;/Button&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      );&#10;    }&#10;&#10;    return this.props.children;&#10;  }&#10;}&#10;&#10;// 특정 컴포넌트를 위한 간단한 에러 바운더리 HOC&#10;export function withErrorBoundary&lt;P extends object&gt;(&#10;  Component: React.ComponentType&lt;P&gt;,&#10;  fallback?: ReactNode&#10;) {&#10;  const WrappedComponent = (props: P) =&gt; (&#10;    &lt;ErrorBoundary fallback={fallback}&gt;&#10;      &lt;Component {...props} /&gt;&#10;    &lt;/ErrorBoundary&gt;&#10;  );&#10;&#10;  WrappedComponent.displayName = `withErrorBoundary(${Component.displayName || Component.name})`;&#10;  return WrappedComponent;&#10;}&#10;&#10;// 함수형 컴포넌트를 위한 훅&#10;export function useErrorHandler() {&#10;  return (error: Error, errorInfo?: any) =&gt; {&#10;    console.error('Manual error report:', error, errorInfo);&#10;&#10;    // 여기서 에러 리포팅 서비스로 전송&#10;    if (typeof window !== 'undefined') {&#10;      // 실제 구현에서는 에러 서비스 API 호출&#10;      console.log('Error reported to service:', {&#10;        error: error.message,&#10;        stack: error.stack,&#10;        userAgent: navigator.userAgent,&#10;        url: window.location.href,&#10;        timestamp: new Date().toISOString(),&#10;        additionalInfo: errorInfo,&#10;      });&#10;    }&#10;  };&#10;}&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#13;&#10;&#13;&#10;import React, { Component, ErrorInfo, ReactNode } from 'react';&#13;&#10;import { Button } from '@/components/ui/button';&#13;&#10;import { AlertTriangle, RefreshCw, Home } from 'lucide-react';&#13;&#10;&#13;&#10;interface Props {&#13;&#10;  children: ReactNode;&#13;&#10;  fallback?: ReactNode;&#13;&#10;  onError?: (error: Error, errorInfo: ErrorInfo) =&gt; void;&#13;&#10;}&#13;&#10;&#13;&#10;interface State {&#13;&#10;  hasError: boolean;&#13;&#10;  error: Error | null;&#13;&#10;  errorInfo: ErrorInfo | null;&#13;&#10;}&#13;&#10;&#13;&#10;export class ErrorBoundary extends Component&lt;Props, State&gt; {&#13;&#10;  constructor(props: Props) {&#13;&#10;    super(props);&#13;&#10;    this.state = { hasError: false, error: null, errorInfo: null };&#13;&#10;  }&#13;&#10;&#13;&#10;  static getDerivedStateFromError(error: Error): State {&#13;&#10;    return {&#13;&#10;      hasError: true,&#13;&#10;      error,&#13;&#10;      errorInfo: null,&#13;&#10;    };&#13;&#10;  }&#13;&#10;&#13;&#10;  componentDidCatch(error: Error, errorInfo: ErrorInfo) {&#13;&#10;    console.error('ErrorBoundary caught an error:', error, errorInfo);&#13;&#10;&#13;&#10;    this.setState({&#13;&#10;      error,&#13;&#10;      errorInfo,&#13;&#10;    });&#13;&#10;&#13;&#10;    // 사용자 정의 에러 핸들러 호출&#13;&#10;    if (this.props.onError) {&#13;&#10;      this.props.onError(error, errorInfo);&#13;&#10;    }&#13;&#10;&#13;&#10;    // 에러 로깅 (실제 서비스에서는 에러 리포팅 서비스로 전송)&#13;&#10;    this.logErrorToService(error, errorInfo);&#13;&#10;  }&#13;&#10;&#13;&#10;  private logErrorToService = (error: Error, errorInfo: ErrorInfo) =&gt; {&#13;&#10;    // 여기서 실제 에러 리포팅 서비스(Sentry, LogRocket 등)로 전송할 수 있습니다&#13;&#10;    console.log('Error logged:', {&#13;&#10;      error: error.message,&#13;&#10;      stack: error.stack,&#13;&#10;      componentStack: errorInfo.componentStack,&#13;&#10;      timestamp: new Date().toISOString(),&#13;&#10;    });&#13;&#10;  };&#13;&#10;&#13;&#10;  private handleReload = () =&gt; {&#13;&#10;    window.location.reload();&#13;&#10;  };&#13;&#10;&#13;&#10;  private handleGoHome = () =&gt; {&#13;&#10;    window.location.href = '/';&#13;&#10;  };&#13;&#10;&#13;&#10;  private handleRetry = () =&gt; {&#13;&#10;    this.setState({ hasError: false, error: null, errorInfo: null });&#13;&#10;  };&#13;&#10;&#13;&#10;  render() {&#13;&#10;    if (this.state.hasError) {&#13;&#10;      // 사용자 정의 fallback UI가 있으면 사용&#13;&#10;      if (this.props.fallback) {&#13;&#10;        return this.props.fallback;&#13;&#10;      }&#13;&#10;&#13;&#10;      // 기본 에러 UI&#13;&#10;      return (&#13;&#10;        &lt;div className=&quot;min-h-screen flex items-center justify-center bg-gray-50 dark:bg-zinc-900&quot;&gt;&#13;&#10;          &lt;div className=&quot;max-w-md w-full bg-white dark:bg-zinc-800 rounded-lg shadow-lg p-6 border border-gray-200 dark:border-zinc-700&quot;&gt;&#13;&#10;            &lt;div className=&quot;flex items-center justify-center w-12 h-12 mx-auto bg-red-100 dark:bg-red-900/20 rounded-full mb-4&quot;&gt;&#13;&#10;              &lt;AlertTriangle className=&quot;w-6 h-6 text-red-600 dark:text-red-400&quot; /&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;&#13;&#10;            &lt;h1 className=&quot;text-xl font-semibold text-gray-900 dark:text-gray-100 text-center mb-2&quot;&gt;&#13;&#10;              앗, 문제가 발생했습니다!&#13;&#10;            &lt;/h1&gt;&#13;&#10;&#13;&#10;            &lt;p className=&quot;text-gray-600 dark:text-gray-300 text-center mb-6&quot;&gt;&#13;&#10;              예상치 못한 오류가 발생했습니다. 페이지를 새로고침하거나 홈으로 돌아가 보세요.&#13;&#10;            &lt;/p&gt;&#13;&#10;&#13;&#10;            {/* 개발 환경에서만 에러 세부 정보 표시 */}&#13;&#10;            {process.env.NODE_ENV === 'development' &amp;&amp; this.state.error &amp;&amp; (&#13;&#10;              &lt;details className=&quot;mb-4 p-3 bg-gray-100 dark:bg-zinc-700 rounded text-sm&quot;&gt;&#13;&#10;                &lt;summary className=&quot;cursor-pointer font-medium text-gray-700 dark:text-gray-300&quot;&gt;&#13;&#10;                  에러 세부 정보 (개발 모드)&#13;&#10;                &lt;/summary&gt;&#13;&#10;                &lt;div className=&quot;mt-2 text-red-600 dark:text-red-400 font-mono text-xs whitespace-pre-wrap&quot;&gt;&#13;&#10;                  {this.state.error.message}&#13;&#10;                  {this.state.error.stack &amp;&amp; (&#13;&#10;                    &lt;div className=&quot;mt-2 opacity-75&quot;&gt;&#13;&#10;                      {this.state.error.stack}&#13;&#10;                    &lt;/div&gt;&#13;&#10;                  )}&#13;&#10;                &lt;/div&gt;&#13;&#10;              &lt;/details&gt;&#13;&#10;            )}&#13;&#10;&#13;&#10;            &lt;div className=&quot;flex flex-col sm:flex-row gap-3&quot;&gt;&#13;&#10;              &lt;Button&#13;&#10;                onClick={this.handleRetry}&#13;&#10;                className=&quot;flex-1 flex items-center justify-center gap-2&quot;&#13;&#10;                variant=&quot;outline&quot;&#13;&#10;              &gt;&#13;&#10;                &lt;RefreshCw className=&quot;w-4 h-4&quot; /&gt;&#13;&#10;                다시 시도&#13;&#10;              &lt;/Button&gt;&#13;&#10;&#13;&#10;              &lt;Button&#13;&#10;                onClick={this.handleReload}&#13;&#10;                className=&quot;flex-1 flex items-center justify-center gap-2&quot;&#13;&#10;                variant=&quot;outline&quot;&#13;&#10;              &gt;&#13;&#10;                &lt;RefreshCw className=&quot;w-4 h-4&quot; /&gt;&#13;&#10;                새로고침&#13;&#10;              &lt;/Button&gt;&#13;&#10;&#13;&#10;              &lt;Button&#13;&#10;                onClick={this.handleGoHome}&#13;&#10;                className=&quot;flex-1 flex items-center justify-center gap-2&quot;&#13;&#10;              &gt;&#13;&#10;                &lt;Home className=&quot;w-4 h-4&quot; /&gt;&#13;&#10;                홈으로&#13;&#10;              &lt;/Button&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;          &lt;/div&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      );&#13;&#10;    }&#13;&#10;&#13;&#10;    return this.props.children;&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;// 특정 컴포넌트를 위한 간단한 에러 바운더리 HOC&#13;&#10;export function withErrorBoundary&lt;P extends object&gt;(&#13;&#10;  Component: React.ComponentType&lt;P&gt;,&#13;&#10;  fallback?: ReactNode&#13;&#10;) {&#13;&#10;  const WrappedComponent = (props: P) =&gt; (&#13;&#10;    &lt;ErrorBoundary fallback={fallback}&gt;&#13;&#10;      &lt;Component {...props} /&gt;&#13;&#10;    &lt;/ErrorBoundary&gt;&#13;&#10;  );&#13;&#10;&#13;&#10;  WrappedComponent.displayName = `withErrorBoundary(${Component.displayName || Component.name})`;&#13;&#10;  return WrappedComponent;&#13;&#10;}&#13;&#10;&#13;&#10;// 함수형 컴포넌트를 위한 훅&#13;&#10;export function useErrorHandler() {&#13;&#10;  return (error: Error, errorInfo?: Record&lt;string, unknown&gt;) =&gt; {&#13;&#10;    console.error('Manual error report:', error, errorInfo);&#13;&#10;    &#13;&#10;    // 여기서 에러 리포팅 서비스로 전송&#13;&#10;    if (typeof window !== 'undefined') {&#13;&#10;      // 실제 구현에서는 에러 서비스 API 호출&#13;&#10;      console.log('Error reported to service:', {&#13;&#10;        error: error.message,&#13;&#10;        stack: error.stack,&#13;&#10;        userAgent: navigator.userAgent,&#13;&#10;        url: window.location.href,&#13;&#10;        timestamp: new Date().toISOString(),&#13;&#10;        additionalInfo: errorInfo,&#13;&#10;      });&#13;&#10;    }&#13;&#10;  };&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/load-from-gist-modal.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/load-from-gist-modal.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;import React, { useState } from &quot;react&quot;;&#10;import { Button } from &quot;@/components/ui/button&quot;;&#10;import { Input } from &quot;@/components/ui/input&quot;;&#10;import { Label } from &quot;@/components/ui/label&quot;;&#10;import { X } from &quot;lucide-react&quot;;&#10;import { toast } from &quot;sonner&quot;;&#10;import { loadFromGist, isValidGistUrl, type CollectionData } from &quot;@/services/gist&quot;;&#10;&#10;interface LoadFromGistModalProps {&#10;  onClose: () =&gt; void;&#10;  onLoad: (data: CollectionData) =&gt; void;&#10;}&#10;&#10;export function LoadFromGistModal({ onClose, onLoad }: LoadFromGistModalProps) {&#10;  const [gistUrl, setGistUrl] = useState(&quot;&quot;);&#10;  const [isLoading, setIsLoading] = useState(false);&#10;&#10;  const handleLoad = async () =&gt; {&#10;    if (!gistUrl.trim()) {&#10;      toast.error(&quot;Gist URL을 입력해주세요.&quot;);&#10;      return;&#10;    }&#10;&#10;    if (!isValidGistUrl(gistUrl.trim())) {&#10;      toast.error(&quot;올바른 GitHub Gist URL을 입력해주세요.&quot;);&#10;      return;&#10;    }&#10;&#10;    setIsLoading(true);&#10;    try {&#10;      const data = await loadFromGist(gistUrl.trim());&#10;      onLoad(data);&#10;      toast.success(&quot;컬렉션을 성공적으로 불러왔습니다!&quot;);&#10;      onClose();&#10;    } catch (error) {&#10;      console.error(&quot;Gist 로드 오류:&quot;, error);&#10;      toast.error(error instanceof Error ? error.message : &quot;컬렉션을 불러오는데 실패했습니다.&quot;);&#10;    } finally {&#10;      setIsLoading(false);&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;fixed inset-0 bg-black/40 flex items-center justify-center z-50 animate-fadein&quot;&gt;&#10;      &lt;div className=&quot;relative w-full max-w-md bg-white dark:bg-zinc-900 rounded-xl shadow-lg border border-zinc-200 dark:border-zinc-800 p-6&quot;&gt;&#10;        &lt;h2 className=&quot;text-xl font-bold mb-4&quot;&gt;Gist에서 컬렉션 불러오기&lt;/h2&gt;&#10;        &lt;button&#10;          className=&quot;absolute top-3 right-3 text-zinc-500 hover:text-zinc-800 dark:hover:text-zinc-200 transition-colors&quot;&#10;          onClick={onClose}&#10;          aria-label=&quot;닫기&quot;&#10;        &gt;&#10;          &lt;X className=&quot;w-6 h-6&quot; /&gt;&#10;        &lt;/button&gt;&#10;&#10;        &lt;div className=&quot;mb-4&quot;&gt;&#10;          &lt;Label htmlFor=&quot;gist-url&quot; className=&quot;block text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-2&quot;&gt;&#10;            GitHub Gist URL&#10;          &lt;/Label&gt;&#10;          &lt;Input&#10;            id=&quot;gist-url&quot;&#10;            type=&quot;url&quot;&#10;            value={gistUrl}&#10;            onChange={(e) =&gt; setGistUrl(e.target.value)}&#10;            className=&quot;w-full px-3 py-2 border border-zinc-300 dark:border-zinc-700 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm bg-white dark:bg-zinc-800 text-zinc-900 dark:text-zinc-100&quot;&#10;            placeholder=&quot;https://gist.github.com/username/gist-id&quot;&#10;          /&gt;&#10;          &lt;p className=&quot;mt-1 text-xs text-zinc-500 dark:text-zinc-400&quot;&gt;&#10;            공유받은 GitHub Gist URL을 입력하세요&#10;          &lt;/p&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;div className=&quot;flex justify-end space-x-2&quot;&gt;&#10;          &lt;Button variant=&quot;outline&quot; onClick={onClose} disabled={isLoading}&gt;&#10;            취소&#10;          &lt;/Button&gt;&#10;          &lt;Button onClick={handleLoad} disabled={isLoading || !gistUrl.trim()}&gt;&#10;            {isLoading ? &quot;불러오는 중...&quot; : &quot;불러오기&quot;}&#10;          &lt;/Button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#13;&#10;&#13;&#10;import React, { useState } from &quot;react&quot;;&#13;&#10;import { Button } from &quot;@/components/ui/button&quot;;&#13;&#10;import { Input } from &quot;@/components/ui/input&quot;;&#13;&#10;import { Label } from &quot;@/components/ui/label&quot;;&#13;&#10;import { X } from &quot;lucide-react&quot;;&#13;&#10;import { toast } from &quot;sonner&quot;;&#13;&#10;import { useApiCall } from &quot;@/lib/useAsyncState&quot;;&#13;&#10;import { loadFromGist, isValidGistUrl, type CollectionData } from &quot;@/services/gist&quot;;&#13;&#10;&#13;&#10;interface LoadFromGistModalProps {&#13;&#10;  onClose: () =&gt; void;&#13;&#10;  onLoad: (data: CollectionData) =&gt; void;&#13;&#10;}&#13;&#10;&#13;&#10;export function LoadFromGistModal({ onClose, onLoad }: LoadFromGistModalProps) {&#13;&#10;  const [gistUrl, setGistUrl] = useState(&quot;&quot;);&#13;&#10;  const { isLoading, execute } = useApiCall&lt;CollectionData&gt;();&#13;&#10;&#13;&#10;  const handleLoad = async () =&gt; {&#13;&#10;    if (!gistUrl.trim()) {&#13;&#10;      toast.error(&quot;Gist URL을 입력해주세요.&quot;);&#13;&#10;      return;&#13;&#10;    }&#13;&#10;&#13;&#10;    if (!isValidGistUrl(gistUrl.trim())) {&#13;&#10;      toast.error(&quot;올바른 GitHub Gist URL을 입력해주세요.&quot;);&#13;&#10;      return;&#13;&#10;    }&#13;&#10;&#13;&#10;    await execute(async () =&gt; {&#13;&#10;      const data = await loadFromGist(gistUrl.trim());&#13;&#10;      onLoad(data);&#13;&#10;      toast.success(&quot;컬렉션을 성공적으로 불러왔습니다!&quot;);&#13;&#10;      onClose();&#13;&#10;      return data;&#13;&#10;    });&#13;&#10;  };&#13;&#10;&#13;&#10;  return (&#13;&#10;    &lt;div className=&quot;fixed inset-0 bg-black/40 flex items-center justify-center z-50 animate-fadein&quot;&gt;&#13;&#10;      &lt;div className=&quot;relative w-full max-w-md bg-white dark:bg-zinc-900 rounded-xl shadow-lg border border-zinc-200 dark:border-zinc-800 p-6&quot;&gt;&#13;&#10;        &lt;h2 className=&quot;text-xl font-bold mb-4&quot;&gt;Gist에서 컬렉션 불러오기&lt;/h2&gt;&#13;&#10;        &lt;button&#13;&#10;          className=&quot;absolute top-3 right-3 text-zinc-500 hover:text-zinc-800 dark:hover:text-zinc-200 transition-colors&quot;&#13;&#10;          onClick={onClose}&#13;&#10;          aria-label=&quot;닫기&quot;&#13;&#10;        &gt;&#13;&#10;          &lt;X className=&quot;w-6 h-6&quot; /&gt;&#13;&#10;        &lt;/button&gt;&#13;&#10;&#13;&#10;        &lt;div className=&quot;mb-4&quot;&gt;&#13;&#10;          &lt;Label htmlFor=&quot;gist-url&quot; className=&quot;block text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-2&quot;&gt;&#13;&#10;            GitHub Gist URL&#13;&#10;          &lt;/Label&gt;&#13;&#10;          &lt;Input&#13;&#10;            id=&quot;gist-url&quot;&#13;&#10;            type=&quot;url&quot;&#13;&#10;            value={gistUrl}&#13;&#10;            onChange={(e) =&gt; setGistUrl(e.target.value)}&#13;&#10;            className=&quot;w-full px-3 py-2 border border-zinc-300 dark:border-zinc-700 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm bg-white dark:bg-zinc-800 text-zinc-900 dark:text-zinc-100&quot;&#13;&#10;            placeholder=&quot;https://gist.github.com/username/gist-id&quot;&#13;&#10;          /&gt;&#13;&#10;          &lt;p className=&quot;mt-1 text-xs text-zinc-500 dark:text-zinc-400&quot;&gt;&#13;&#10;            공유받은 GitHub Gist URL을 입력하세요&#13;&#10;          &lt;/p&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;&#13;&#10;        &lt;div className=&quot;flex justify-end space-x-2&quot;&gt;&#13;&#10;          &lt;Button variant=&quot;outline&quot; onClick={onClose} disabled={isLoading}&gt;&#13;&#10;            취소&#13;&#10;          &lt;/Button&gt;&#13;&#10;          &lt;Button onClick={handleLoad} disabled={isLoading || !gistUrl.trim()}&gt;&#13;&#10;            {isLoading ? &quot;불러오는 중...&quot; : &quot;불러오기&quot;}&#13;&#10;          &lt;/Button&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    &lt;/div&gt;&#13;&#10;  );&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/storage-connection-modal.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/storage-connection-modal.tsx" />
              <option name="originalContent" value="import * as React from 'react';&#10;import { StorageProvider } from '@/types/storage';&#10;import { storageManager } from '@/lib/storage-manager';&#10;import { Cloud, HardDrive, Loader2, X, Info } from 'lucide-react';&#10;&#10;interface StorageConnectionModalProps {&#10;  onClose: () =&gt; void;&#10;  onConnectionSelected: (provider: StorageProvider) =&gt; void;&#10;}&#10;&#10;export function StorageConnectionModal({ onClose, onConnectionSelected }: StorageConnectionModalProps) {&#10;  const modalRef = React.useRef&lt;HTMLDivElement&gt;(null);&#10;  const [isConnecting, setIsConnecting] = React.useState(false);&#10;  const [connectingProvider, setConnectingProvider] = React.useState&lt;StorageProvider | null&gt;(null);&#10;&#10;  // 키보드 이벤트 처리&#10;  React.useEffect(() =&gt; {&#10;    const handleKeyDown = (e: KeyboardEvent) =&gt; {&#10;      if (e.key === 'Escape' &amp;&amp; !isConnecting) {&#10;        e.preventDefault();&#10;        e.stopPropagation();&#10;        onClose();&#10;      }&#10;      &#10;      // Tab 키 트랩핑&#10;      if (e.key === 'Tab' &amp;&amp; modalRef.current) {&#10;        const focusable = modalRef.current.querySelectorAll&lt;HTMLElement&gt;(&#10;          'a[href], button:not([disabled]), textarea, input, select, [tabindex]:not([tabindex=&quot;-1&quot;])'&#10;        );&#10;        if (focusable.length === 0) return;&#10;        const first = focusable[0];&#10;        const last = focusable[focusable.length - 1];&#10;        if (!e.shiftKey &amp;&amp; document.activeElement === last) {&#10;          e.preventDefault();&#10;          first.focus();&#10;        } else if (e.shiftKey &amp;&amp; document.activeElement === first) {&#10;          e.preventDefault();&#10;          last.focus();&#10;        }&#10;      }&#10;    };&#10;&#10;    document.addEventListener('keydown', handleKeyDown);&#10;    return () =&gt; document.removeEventListener('keydown', handleKeyDown);&#10;  }, [onClose, isConnecting]);&#10;&#10;  // 오버레이 클릭 처리&#10;  const handleOverlayClick = (e: React.MouseEvent&lt;HTMLDivElement&gt;) =&gt; {&#10;    if (e.target === e.currentTarget &amp;&amp; !isConnecting) {&#10;      onClose();&#10;    }&#10;  };&#10;&#10;  const handleProviderSelect = async (provider: StorageProvider) =&gt; {&#10;    if (provider === 'local') {&#10;      onConnectionSelected(provider);&#10;      return;&#10;    }&#10;&#10;    try {&#10;      setIsConnecting(true);&#10;      setConnectingProvider(provider);&#10;      &#10;      await storageManager.connectToProvider(provider);&#10;      onConnectionSelected(provider);&#10;    } catch (error) {&#10;      console.error(`Failed to connect to ${provider}:`, error);&#10;      &#10;      // Show detailed error message&#10;      const errorMessage = error instanceof Error ? error.message : '알 수 없는 오류가 발생했습니다.';&#10;      alert(`${storageManager.getProviderDisplayName(provider)} 연결 실패:\n\n${errorMessage}`);&#10;    } finally {&#10;      setIsConnecting(false);&#10;      setConnectingProvider(null);&#10;    }&#10;  };&#10;&#10;  const handleShowSetupGuide = () =&gt; {&#10;    const guideMessage = `클라우드 스토리지 연동 설정 방법:&#10;&#10; Dropbox 설정:&#10;1. https://www.dropbox.com/developers/apps 방문&#10;2. &quot;Create app&quot; 클릭&#10;3. &quot;Scoped access&quot; 선택&#10;4. &quot;App folder&quot; 또는 &quot;Full Dropbox&quot; 선택  &#10;5. 앱 이름 입력&#10;6. App key를 복사하여 NEXT_PUBLIC_DROPBOX_CLIENT_ID에 설정&#10;7. App secret을 복사하여 DROPBOX_CLIENT_SECRET에 설정&#10;8. OAuth2 redirect URL에 다음 추가:&#10;   http://localhost:3000/auth/dropbox/callback&#10;&#10; Google Drive 설정:&#10;1. https://console.developers.google.com 방문&#10;2. 새 프로젝트 생성 또는 선택&#10;3. &quot;APIs &amp; Services&quot; &gt; &quot;Library&quot; 에서 Google Drive API 활성화&#10;4. &quot;Credentials&quot; &gt; &quot;Create Credentials&quot; &gt; &quot;OAuth 2.0 Client IDs&quot;&#10;5. 애플리케이션 유형을 &quot;Web application&quot; 선택&#10;6. 승인된 JavaScript 원본에 http://localhost:3000 추가&#10;7. 클라이언트 ID를 NEXT_PUBLIC_GOOGLE_CLIENT_ID에 설정&#10;8. API 키도 생성하여 NEXT_PUBLIC_GOOGLE_API_KEY에 설정&#10;&#10;.env.local 파일에 환경 변수를 설정한 후 개발 서버를 재시작하세요.`;&#10;    &#10;    alert(guideMessage);&#10;  };&#10;&#10;  const providers: Array&lt;{&#10;    id: StorageProvider;&#10;    name: string;&#10;    description: string;&#10;    icon: React.ReactNode;&#10;    color: string;&#10;  }&gt; = [&#10;    {&#10;      id: 'local',&#10;      name: '로컬 파일',&#10;      description: '컴퓨터의 파일을 직접 불러오거나 저장합니다',&#10;      icon: &lt;HardDrive className=&quot;h-8 w-8&quot; /&gt;,&#10;      color: 'bg-gray-500 hover:bg-gray-600'&#10;    },&#10;    {&#10;      id: 'dropbox',&#10;      name: 'Dropbox',&#10;      description: 'Dropbox 클라우드 스토리지와 연동합니다',&#10;      icon: &lt;Cloud className=&quot;h-8 w-8&quot; /&gt;,&#10;      color: 'bg-blue-500 hover:bg-blue-600'&#10;    },&#10;    {&#10;      id: 'googledrive',&#10;      name: 'Google Drive',&#10;      description: 'Google Drive 클라우드 스토리지와 연동합니다',&#10;      icon: &lt;Cloud className=&quot;h-8 w-8&quot; /&gt;,&#10;      color: 'bg-green-500 hover:bg-green-600'&#10;    }&#10;  ];&#10;&#10;  return (&#10;    &lt;div &#10;      className=&quot;fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4&quot;&#10;      onClick={handleOverlayClick}&#10;    &gt;&#10;      &lt;div &#10;        ref={modalRef}&#10;        className=&quot;relative w-full max-w-2xl bg-white dark:bg-zinc-900 rounded-xl shadow-lg border border-zinc-200 dark:border-zinc-800 max-h-[90vh] overflow-hidden&quot;&#10;        onClick={(e) =&gt; e.stopPropagation()}&#10;        role=&quot;dialog&quot;&#10;        aria-labelledby=&quot;storage-connection-title&quot;&#10;        aria-modal=&quot;true&quot;&#10;      &gt;&#10;        {/* Header */}&#10;        &lt;div className=&quot;p-6 pb-0 border-b border-zinc-200 dark:border-zinc-800&quot;&gt;&#10;          &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;            &lt;h2 id=&quot;storage-connection-title&quot; className=&quot;text-2xl font-bold text-zinc-900 dark:text-zinc-100&quot;&gt;&#10;              파일 연동 방식 선택&#10;            &lt;/h2&gt;&#10;            &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;              &lt;button&#10;                onClick={onClose}&#10;                disabled={isConnecting}&#10;                className=&quot;text-zinc-500 hover:text-zinc-800 dark:hover:text-zinc-200 transition-colors disabled:opacity-50 disabled:cursor-not-allowed&quot;&#10;                aria-label=&quot;닫기&quot;&#10;              &gt;&#10;                &lt;X className=&quot;w-6 h-6&quot; /&gt;&#10;              &lt;/button&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;          &lt;p className=&quot;text-zinc-600 dark:text-zinc-400 mt-2&quot;&gt;&#10;            컬렉션 파일을 저장하고 불러올 방식을 선택해주세요.&#10;          &lt;/p&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Content */}&#10;        &lt;div className=&quot;p-6&quot;&gt;&#10;          &lt;div className=&quot;grid gap-4&quot;&gt;&#10;            {providers.map((provider) =&gt; (&#10;              &lt;button&#10;                key={provider.id}&#10;                onClick={() =&gt; handleProviderSelect(provider.id)}&#10;                disabled={isConnecting}&#10;                className=&quot;flex items-center gap-4 p-4 border border-zinc-200 dark:border-zinc-700 rounded-lg hover:border-zinc-300 dark:hover:border-zinc-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-left&quot;&#10;              &gt;&#10;                &lt;div className={`p-3 rounded-lg text-white ${provider.color} transition-colors`}&gt;&#10;                  {isConnecting &amp;&amp; connectingProvider === provider.id ? (&#10;                    &lt;Loader2 className=&quot;h-8 w-8 animate-spin&quot; /&gt;&#10;                  ) : (&#10;                    provider.icon&#10;                  )}&#10;                &lt;/div&gt;&#10;                &lt;div className=&quot;flex-1&quot;&gt;&#10;                  &lt;h3 className=&quot;text-lg font-semibold text-zinc-900 dark:text-zinc-100&quot;&gt;&#10;                    {provider.name}&#10;                  &lt;/h3&gt;&#10;                  &lt;p className=&quot;text-sm text-zinc-600 dark:text-zinc-400&quot;&gt;&#10;                    {provider.description}&#10;                  &lt;/p&gt;&#10;                  {isConnecting &amp;&amp; connectingProvider === provider.id &amp;&amp; (&#10;                    &lt;p className=&quot;text-sm text-blue-600 dark:text-blue-400 mt-1&quot;&gt;&#10;                      연결 중...&#10;                    &lt;/p&gt;&#10;                  )}&#10;                &lt;/div&gt;&#10;              &lt;/button&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Loading overlay */}&#10;        {isConnecting &amp;&amp; (&#10;          &lt;div className=&quot;absolute inset-0 bg-black/20 dark:bg-black/40 flex items-center justify-center rounded-xl backdrop-blur-sm&quot;&gt;&#10;            &lt;div className=&quot;bg-white dark:bg-zinc-800 p-6 rounded-lg shadow-lg border border-zinc-200 dark:border-zinc-700 flex flex-col items-center gap-4&quot;&gt;&#10;              &lt;Loader2 className=&quot;h-8 w-8 animate-spin text-blue-600&quot; /&gt;&#10;              &lt;div className=&quot;text-center&quot;&gt;&#10;                &lt;p className=&quot;font-medium text-zinc-900 dark:text-zinc-100&quot;&gt;&#10;                  {storageManager.getProviderDisplayName(connectingProvider!)}에 연결 중...&#10;                &lt;/p&gt;&#10;                &lt;p className=&quot;text-sm text-zinc-600 dark:text-zinc-400 mt-1&quot;&gt;&#10;                  새 창에서 인증을 완료해주세요&#10;                &lt;/p&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import * as React from 'react';&#10;import { StorageProvider } from '@/types/storage';&#10;import { storageManager } from '@/lib/storage-manager';&#10;import { Cloud, HardDrive, Loader2, X } from 'lucide-react';&#10;&#10;interface StorageConnectionModalProps {&#10;  onClose: () =&gt; void;&#10;  onConnectionSelected: (provider: StorageProvider) =&gt; void;&#10;}&#10;&#10;export function StorageConnectionModal({ onClose, onConnectionSelected }: StorageConnectionModalProps) {&#10;  const modalRef = React.useRef&lt;HTMLDivElement&gt;(null);&#10;  const [isConnecting, setIsConnecting] = React.useState(false);&#10;  const [connectingProvider, setConnectingProvider] = React.useState&lt;StorageProvider | null&gt;(null);&#10;&#10;  // 키보드 이벤트 처리&#10;  React.useEffect(() =&gt; {&#10;    const handleKeyDown = (e: KeyboardEvent) =&gt; {&#10;      if (e.key === 'Escape' &amp;&amp; !isConnecting) {&#10;        e.preventDefault();&#10;        e.stopPropagation();&#10;        onClose();&#10;      }&#10;      &#10;      // Tab 키 트랩핑&#10;      if (e.key === 'Tab' &amp;&amp; modalRef.current) {&#10;        const focusable = modalRef.current.querySelectorAll&lt;HTMLElement&gt;(&#10;          'a[href], button:not([disabled]), textarea, input, select, [tabindex]:not([tabindex=&quot;-1&quot;])'&#10;        );&#10;        if (focusable.length === 0) return;&#10;        const first = focusable[0];&#10;        const last = focusable[focusable.length - 1];&#10;        if (!e.shiftKey &amp;&amp; document.activeElement === last) {&#10;          e.preventDefault();&#10;          first.focus();&#10;        } else if (e.shiftKey &amp;&amp; document.activeElement === first) {&#10;          e.preventDefault();&#10;          last.focus();&#10;        }&#10;      }&#10;    };&#10;&#10;    document.addEventListener('keydown', handleKeyDown);&#10;    return () =&gt; document.removeEventListener('keydown', handleKeyDown);&#10;  }, [onClose, isConnecting]);&#10;&#10;  // 오버레이 클릭 처리&#10;  const handleOverlayClick = (e: React.MouseEvent&lt;HTMLDivElement&gt;) =&gt; {&#10;    if (e.target === e.currentTarget &amp;&amp; !isConnecting) {&#10;      onClose();&#10;    }&#10;  };&#10;&#10;  const handleProviderSelect = async (provider: StorageProvider) =&gt; {&#10;    if (provider === 'local') {&#10;      onConnectionSelected(provider);&#10;      return;&#10;    }&#10;&#10;    try {&#10;      setIsConnecting(true);&#10;      setConnectingProvider(provider);&#10;      &#10;      await storageManager.connectToProvider(provider);&#10;      onConnectionSelected(provider);&#10;    } catch (error) {&#10;      console.error(`Failed to connect to ${provider}:`, error);&#10;      &#10;      // Show detailed error message&#10;      const errorMessage = error instanceof Error ? error.message : '알 수 없는 오류가 발생했습니다.';&#10;      alert(`연결 실패:\n\n${errorMessage}`);&#10;    } finally {&#10;      setIsConnecting(false);&#10;      setConnectingProvider(null);&#10;    }&#10;  };&#10;&#10;  const providers: Array&lt;{&#10;    id: StorageProvider;&#10;    name: string;&#10;    description: string;&#10;    icon: React.ReactNode;&#10;    color: string;&#10;  }&gt; = [&#10;    {&#10;      id: 'local',&#10;      name: '로컬 파일',&#10;      description: '컴퓨터의 파일을 직접 불러오거나 저장합니다',&#10;      icon: &lt;HardDrive className=&quot;h-8 w-8&quot; /&gt;,&#10;      color: 'bg-gray-500 hover:bg-gray-600'&#10;    },&#10;    {&#10;      id: 'dropbox',&#10;      name: 'Dropbox',&#10;      description: 'Dropbox 클라우드 스토리지와 연동합니다',&#10;      icon: &lt;Cloud className=&quot;h-8 w-8&quot; /&gt;,&#10;      color: 'bg-blue-500 hover:bg-blue-600'&#10;    },&#10;    {&#10;      id: 'googledrive',&#10;      name: 'Google Drive',&#10;      description: 'Google Drive 클라우드 스토리지와 연동합니다',&#10;      icon: &lt;Cloud className=&quot;h-8 w-8&quot; /&gt;,&#10;      color: 'bg-green-500 hover:bg-green-600'&#10;    }&#10;  ];&#10;&#10;  return (&#10;    &lt;div &#10;      className=&quot;fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4&quot;&#10;      onClick={handleOverlayClick}&#10;    &gt;&#10;      &lt;div &#10;        ref={modalRef}&#10;        className=&quot;relative w-full max-w-2xl bg-white dark:bg-zinc-900 rounded-xl shadow-lg border border-zinc-200 dark:border-zinc-800 max-h-[90vh] overflow-hidden&quot;&#10;        onClick={(e) =&gt; e.stopPropagation()}&#10;        role=&quot;dialog&quot;&#10;        aria-labelledby=&quot;storage-connection-title&quot;&#10;        aria-modal=&quot;true&quot;&#10;      &gt;&#10;        {/* Header */}&#10;        &lt;div className=&quot;p-6 pb-0 border-b border-zinc-200 dark:border-zinc-800&quot;&gt;&#10;          &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;            &lt;h2 id=&quot;storage-connection-title&quot; className=&quot;text-2xl font-bold text-zinc-900 dark:text-zinc-100&quot;&gt;&#10;              파일 연동 방식 선택&#10;            &lt;/h2&gt;&#10;            &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;              &lt;button&#10;                onClick={onClose}&#10;                disabled={isConnecting}&#10;                className=&quot;text-zinc-500 hover:text-zinc-800 dark:hover:text-zinc-200 transition-colors disabled:opacity-50 disabled:cursor-not-allowed&quot;&#10;                aria-label=&quot;닫기&quot;&#10;              &gt;&#10;                &lt;X className=&quot;w-6 h-6&quot; /&gt;&#10;              &lt;/button&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;          &lt;p className=&quot;text-zinc-600 dark:text-zinc-400 mt-2&quot;&gt;&#10;            컬렉션 파일을 저장하고 불러올 방식을 선택해주세요.&#10;          &lt;/p&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Content */}&#10;        &lt;div className=&quot;p-6&quot;&gt;&#10;          &lt;div className=&quot;grid gap-4&quot;&gt;&#10;            {providers.map((provider) =&gt; (&#10;              &lt;button&#10;                key={provider.id}&#10;                onClick={() =&gt; handleProviderSelect(provider.id)}&#10;                disabled={isConnecting}&#10;                className=&quot;flex items-center gap-4 p-4 border border-zinc-200 dark:border-zinc-700 rounded-lg hover:border-zinc-300 dark:hover:border-zinc-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-left&quot;&#10;              &gt;&#10;                &lt;div className={`p-3 rounded-lg text-white ${provider.color} transition-colors`}&gt;&#10;                  {isConnecting &amp;&amp; connectingProvider === provider.id ? (&#10;                    &lt;Loader2 className=&quot;h-8 w-8 animate-spin&quot; /&gt;&#10;                  ) : (&#10;                    provider.icon&#10;                  )}&#10;                &lt;/div&gt;&#10;                &lt;div className=&quot;flex-1&quot;&gt;&#10;                  &lt;h3 className=&quot;text-lg font-semibold text-zinc-900 dark:text-zinc-100&quot;&gt;&#10;                    {provider.name}&#10;                  &lt;/h3&gt;&#10;                  &lt;p className=&quot;text-sm text-zinc-600 dark:text-zinc-400&quot;&gt;&#10;                    {provider.description}&#10;                  &lt;/p&gt;&#10;                  {isConnecting &amp;&amp; connectingProvider === provider.id &amp;&amp; (&#10;                    &lt;p className=&quot;text-sm text-blue-600 dark:text-blue-400 mt-1&quot;&gt;&#10;                      연결 중...&#10;                    &lt;/p&gt;&#10;                  )}&#10;                &lt;/div&gt;&#10;              &lt;/button&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Loading overlay */}&#10;        {isConnecting &amp;&amp; (&#10;          &lt;div className=&quot;absolute inset-0 bg-black/20 dark:bg-black/40 flex items-center justify-center rounded-xl backdrop-blur-sm&quot;&gt;&#10;            &lt;div className=&quot;bg-white dark:bg-zinc-800 p-6 rounded-lg shadow-lg border border-zinc-200 dark:border-zinc-700 flex flex-col items-center gap-4&quot;&gt;&#10;              &lt;Loader2 className=&quot;h-8 w-8 animate-spin text-blue-600&quot; /&gt;&#10;              &lt;div className=&quot;text-center&quot;&gt;&#10;                &lt;p className=&quot;font-medium text-zinc-900 dark:text-zinc-100&quot;&gt;&#10;                  {storageManager.getProviderDisplayName(connectingProvider!)}에 연결 중...&#10;                &lt;/p&gt;&#10;                &lt;p className=&quot;text-sm text-zinc-600 dark:text-zinc-400 mt-1&quot;&gt;&#10;                  새 창에서 인증을 완료해주세요&#10;                &lt;/p&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/virtualized-album-grid.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/virtualized-album-grid.tsx" />
              <option name="originalContent" value="import * as React from &quot;react&quot;;&#10;import type { Album } from &quot;@/types/album&quot;;&#10;import { AlbumCard } from &quot;@/components/album-card&quot;;&#10;&#10;interface VirtualizedAlbumGridProps {&#10;  albums: Album[];&#10;  onAlbumClick?: (album: Album) =&gt; void;&#10;  onEditAlbum?: (album: Album) =&gt; void;&#10;  onDeleteAlbum?: (album: Album) =&gt; void;&#10;  itemsPerPage?: number;&#10;}&#10;&#10;/**&#10; * 대용량 앨범 컬렉션을 위한 가상화된 그리드 컴포넌트&#10; * 한 번에 일정 수의 앨범만 렌더링하여 성능을 최적화&#10; */&#10;export function VirtualizedAlbumGrid({&#10;  albums,&#10;  onAlbumClick,&#10;  onEditAlbum,&#10;  onDeleteAlbum,&#10;  itemsPerPage = 50 // 한 번에 50개씩 렌더링&#10;}: VirtualizedAlbumGridProps) {&#10;  const [currentPage, setCurrentPage] = React.useState(0);&#10;  const [loadedPages, setLoadedPages] = React.useState&lt;Set&lt;number&gt;&gt;(new Set([0]));&#10;  const containerRef = React.useRef&lt;HTMLDivElement&gt;(null);&#10;  const loadingRef = React.useRef&lt;HTMLDivElement&gt;(null);&#10;&#10;  // 현재까지 로드된 앨범들&#10;  const totalPages = Math.ceil(albums.length / itemsPerPage);&#10;  const maxLoadedPage = Math.max(...Array.from(loadedPages));&#10;  const visibleAlbums = albums.slice(0, (maxLoadedPage + 1) * itemsPerPage);&#10;&#10;  // Intersection Observer를 사용한 무한 스크롤&#10;  React.useEffect(() =&gt; {&#10;    if (!loadingRef.current) return;&#10;&#10;    const observer = new IntersectionObserver(&#10;      (entries) =&gt; {&#10;        const target = entries[0];&#10;        if (target.isIntersecting &amp;&amp; maxLoadedPage &lt; totalPages - 1) {&#10;          const nextPage = maxLoadedPage + 1;&#10;          setLoadedPages(prev =&gt; new Set([...prev, nextPage]));&#10;          setCurrentPage(nextPage);&#10;        }&#10;      },&#10;      {&#10;        root: null,&#10;        rootMargin: '100px', // 100px 전에 미리 로드&#10;        threshold: 0.1,&#10;      }&#10;    );&#10;&#10;    observer.observe(loadingRef.current);&#10;&#10;    return () =&gt; {&#10;      observer.disconnect();&#10;    };&#10;  }, [maxLoadedPage, totalPages]);&#10;&#10;  // 스크롤 위치 복원&#10;  React.useEffect(() =&gt; {&#10;    const container = containerRef.current;&#10;    if (!container) return;&#10;&#10;    const handleScroll = () =&gt; {&#10;      // 스크롤 위치를 sessionStorage에 저장&#10;      sessionStorage.setItem('albumGridScrollTop', container.scrollTop.toString());&#10;    };&#10;&#10;    container.addEventListener('scroll', handleScroll);&#10;&#10;    // 컴포넌트 마운트 시 스크롤 위치 복원&#10;    const savedScrollTop = sessionStorage.getItem('albumGridScrollTop');&#10;    if (savedScrollTop) {&#10;      container.scrollTop = parseInt(savedScrollTop, 10);&#10;    }&#10;&#10;    return () =&gt; {&#10;      container.removeEventListener('scroll', handleScroll);&#10;    };&#10;  }, []);&#10;&#10;  if (albums.length === 0) {&#10;    return &lt;div className=&quot;text-zinc-400 text-center py-8&quot;&gt;등록된 앨범이 없습니다.&lt;/div&gt;;&#10;  }&#10;&#10;  return (&#10;    &lt;div&#10;      ref={containerRef}&#10;      className=&quot;max-h-[80vh] overflow-y-auto&quot;&#10;    &gt;&#10;      &lt;div className=&quot;grid grid-cols-1 xs:grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-3 sm:gap-4 md:gap-6 w-full&quot;&gt;&#10;        {visibleAlbums.map((album) =&gt; (&#10;          &lt;AlbumCard&#10;            key={album.id}&#10;            album={album}&#10;            onClick={() =&gt; onAlbumClick?.(album)}&#10;            onDelete={() =&gt; onDeleteAlbum?.(album)}&#10;            onEdit={() =&gt; onEditAlbum?.(album)}&#10;          /&gt;&#10;        ))}&#10;      &lt;/div&gt;&#10;&#10;      {/* 로딩 트리거 및 상태 표시 */}&#10;      {maxLoadedPage &lt; totalPages - 1 &amp;&amp; (&#10;        &lt;div&#10;          ref={loadingRef}&#10;          className=&quot;flex justify-center items-center py-8&quot;&#10;        &gt;&#10;          &lt;div className=&quot;text-zinc-500 text-sm&quot;&gt;&#10;            더 많은 앨범 로딩 중... ({visibleAlbums.length}/{albums.length})&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      )}&#10;&#10;      {/* 모든 앨범이 로드된 경우 */}&#10;      {maxLoadedPage &gt;= totalPages - 1 &amp;&amp; albums.length &gt; itemsPerPage &amp;&amp; (&#10;        &lt;div className=&quot;text-center py-4 text-zinc-500 text-sm&quot;&gt;&#10;          총 {albums.length}개의 앨범을 모두 표시했습니다.&#10;        &lt;/div&gt;&#10;      )}&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;/**&#10; * 기존 AlbumGrid와의 호환성을 위한 래퍼 컴포넌트&#10; */&#10;export function AlbumGrid({ albums, onAlbumClick, onEditAlbum, onDeleteAlbum }: VirtualizedAlbumGridProps) {&#10;  // 앨범 수가 적으면 기존 방식, 많으면 가상화 사용&#10;  const shouldUseVirtualization = albums.length &gt; 100;&#10;&#10;  if (!shouldUseVirtualization) {&#10;    // 기존 방식 (100개 이하)&#10;    if (albums.length === 0) {&#10;      return &lt;div className=&quot;text-zinc-400 text-center py-8&quot;&gt;등록된 앨범이 없습니다.&lt;/div&gt;;&#10;    }&#10;&#10;    return (&#10;      &lt;div className=&quot;grid grid-cols-1 xs:grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-3 sm:gap-4 md:gap-6 w-full&quot;&gt;&#10;        {albums.map((album) =&gt; (&#10;          &lt;AlbumCard&#10;            key={album.id}&#10;            album={album}&#10;            onClick={() =&gt; onAlbumClick?.(album)}&#10;            onDelete={() =&gt; onDeleteAlbum?.(album)}&#10;            onEdit={() =&gt; onEditAlbum?.(album)}&#10;          /&gt;&#10;        ))}&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  // 가상화 방식 (100개 초과)&#10;  return (&#10;    &lt;VirtualizedAlbumGrid&#10;      albums={albums}&#10;      onAlbumClick={onAlbumClick}&#10;      onEditAlbum={onEditAlbum}&#10;      onDeleteAlbum={onDeleteAlbum}&#10;    /&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import * as React from &quot;react&quot;;&#13;&#10;import type { Album } from &quot;@/types/album&quot;;&#13;&#10;import { AlbumCard } from &quot;@/components/album-card&quot;;&#13;&#10;&#13;&#10;interface VirtualizedAlbumGridProps {&#13;&#10;  albums: Album[];&#13;&#10;  onAlbumClick?: (album: Album) =&gt; void;&#13;&#10;  onEditAlbum?: (album: Album) =&gt; void;&#13;&#10;  onDeleteAlbum?: (album: Album) =&gt; void;&#13;&#10;  itemsPerPage?: number;&#13;&#10;}&#13;&#10;&#13;&#10;/**&#13;&#10; * 대용량 앨범 컬렉션을 위한 가상화된 그리드 컴포넌트&#13;&#10; * 한 번에 일정 수의 앨범만 렌더링하여 성능을 최적화&#13;&#10; */&#13;&#10;export function VirtualizedAlbumGrid({&#13;&#10;  albums,&#13;&#10;  onAlbumClick,&#13;&#10;  onEditAlbum,&#13;&#10;  onDeleteAlbum,&#13;&#10;  itemsPerPage = 50 // 한 번에 50개씩 렌더링&#13;&#10;}: VirtualizedAlbumGridProps) {&#13;&#10;  const [loadedPages, setLoadedPages] = React.useState&lt;Set&lt;number&gt;&gt;(new Set([0]));&#13;&#10;  const containerRef = React.useRef&lt;HTMLDivElement&gt;(null);&#13;&#10;  const loadingRef = React.useRef&lt;HTMLDivElement&gt;(null);&#13;&#10;&#13;&#10;  // 현재까지 로드된 앨범들&#13;&#10;  const totalPages = Math.ceil(albums.length / itemsPerPage);&#13;&#10;  const maxLoadedPage = Math.max(...Array.from(loadedPages));&#13;&#10;  const visibleAlbums = albums.slice(0, (maxLoadedPage + 1) * itemsPerPage);&#13;&#10;&#13;&#10;  // Intersection Observer를 사용한 무한 스크롤&#13;&#10;  React.useEffect(() =&gt; {&#13;&#10;    if (!loadingRef.current) return;&#13;&#10;&#13;&#10;    const observer = new IntersectionObserver(&#13;&#10;      (entries) =&gt; {&#13;&#10;        const target = entries[0];&#13;&#10;        if (target.isIntersecting &amp;&amp; maxLoadedPage &lt; totalPages - 1) {&#13;&#10;          const nextPage = maxLoadedPage + 1;&#13;&#10;          setLoadedPages(prev =&gt; new Set([...prev, nextPage]));&#13;&#10;        }&#13;&#10;      },&#13;&#10;      {&#13;&#10;        root: null,&#13;&#10;        rootMargin: '100px', // 100px 전에 미리 로드&#13;&#10;        threshold: 0.1,&#13;&#10;      }&#13;&#10;    );&#13;&#10;&#13;&#10;    observer.observe(loadingRef.current);&#13;&#10;&#13;&#10;    return () =&gt; {&#13;&#10;      observer.disconnect();&#13;&#10;    };&#13;&#10;  }, [maxLoadedPage, totalPages]);&#13;&#10;&#13;&#10;  // 스크롤 위치 복원&#13;&#10;  React.useEffect(() =&gt; {&#13;&#10;    const container = containerRef.current;&#13;&#10;    if (!container) return;&#13;&#10;&#13;&#10;    const handleScroll = () =&gt; {&#13;&#10;      // 스크롤 위치를 sessionStorage에 저장&#13;&#10;      sessionStorage.setItem('albumGridScrollTop', container.scrollTop.toString());&#13;&#10;    };&#13;&#10;&#13;&#10;    container.addEventListener('scroll', handleScroll);&#13;&#10;&#13;&#10;    // 컴포넌트 마운트 시 스크롤 위치 복원&#13;&#10;    const savedScrollTop = sessionStorage.getItem('albumGridScrollTop');&#13;&#10;    if (savedScrollTop) {&#13;&#10;      container.scrollTop = parseInt(savedScrollTop, 10);&#13;&#10;    }&#13;&#10;&#13;&#10;    return () =&gt; {&#13;&#10;      container.removeEventListener('scroll', handleScroll);&#13;&#10;    };&#13;&#10;  }, []);&#13;&#10;&#13;&#10;  if (albums.length === 0) {&#13;&#10;    return &lt;div className=&quot;text-zinc-400 text-center py-8&quot;&gt;등록된 앨범이 없습니다.&lt;/div&gt;;&#13;&#10;  }&#13;&#10;&#13;&#10;  return (&#13;&#10;    &lt;div&#13;&#10;      ref={containerRef}&#13;&#10;      className=&quot;max-h-[80vh] overflow-y-auto&quot;&#13;&#10;    &gt;&#13;&#10;      &lt;div className=&quot;grid grid-cols-1 xs:grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-3 sm:gap-4 md:gap-6 w-full&quot;&gt;&#13;&#10;        {visibleAlbums.map((album) =&gt; (&#13;&#10;          &lt;AlbumCard&#13;&#10;            key={album.id}&#13;&#10;            album={album}&#13;&#10;            onClick={() =&gt; onAlbumClick?.(album)}&#13;&#10;            onDelete={() =&gt; onDeleteAlbum?.(album)}&#13;&#10;            onEdit={() =&gt; onEditAlbum?.(album)}&#13;&#10;          /&gt;&#13;&#10;        ))}&#13;&#10;      &lt;/div&gt;&#13;&#10;&#13;&#10;      {/* 로딩 트리거 및 상태 표시 */}&#13;&#10;      {maxLoadedPage &lt; totalPages - 1 &amp;&amp; (&#13;&#10;        &lt;div&#13;&#10;          ref={loadingRef}&#13;&#10;          className=&quot;flex justify-center items-center py-8&quot;&#13;&#10;        &gt;&#13;&#10;          &lt;div className=&quot;text-zinc-500 text-sm&quot;&gt;&#13;&#10;            더 많은 앨범 로딩 중... ({visibleAlbums.length}/{albums.length})&#13;&#10;          &lt;/div&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      )}&#13;&#10;&#13;&#10;      {/* 모든 앨범이 로드된 경우 */}&#13;&#10;      {maxLoadedPage &gt;= totalPages - 1 &amp;&amp; albums.length &gt; itemsPerPage &amp;&amp; (&#13;&#10;        &lt;div className=&quot;text-center py-4 text-zinc-500 text-sm&quot;&gt;&#13;&#10;          총 {albums.length}개의 앨범을 모두 표시했습니다.&#13;&#10;        &lt;/div&gt;&#13;&#10;      )}&#13;&#10;    &lt;/div&gt;&#13;&#10;  );&#13;&#10;}&#13;&#10;&#13;&#10;/**&#13;&#10; * 기존 AlbumGrid와의 호환성을 위한 래퍼 컴포넌트&#13;&#10; */&#13;&#10;export function AlbumGrid({ albums, onAlbumClick, onEditAlbum, onDeleteAlbum }: VirtualizedAlbumGridProps) {&#13;&#10;  // 앨범 수가 적으면 기존 방식, 많으면 가상화 사용&#13;&#10;  const shouldUseVirtualization = albums.length &gt; 100;&#13;&#10;&#13;&#10;  if (!shouldUseVirtualization) {&#13;&#10;    // 기존 방식 (100개 이하)&#13;&#10;    if (albums.length === 0) {&#13;&#10;      return &lt;div className=&quot;text-zinc-400 text-center py-8&quot;&gt;등록된 앨범이 없습니다.&lt;/div&gt;;&#13;&#10;    }&#13;&#10;&#13;&#10;    return (&#13;&#10;      &lt;div className=&quot;grid grid-cols-1 xs:grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-3 sm:gap-4 md:gap-6 w-full&quot;&gt;&#13;&#10;        {albums.map((album) =&gt; (&#13;&#10;          &lt;AlbumCard&#13;&#10;            key={album.id}&#13;&#10;            album={album}&#13;&#10;            onClick={() =&gt; onAlbumClick?.(album)}&#13;&#10;            onDelete={() =&gt; onDeleteAlbum?.(album)}&#13;&#10;            onEdit={() =&gt; onEditAlbum?.(album)}&#13;&#10;          /&gt;&#13;&#10;        ))}&#13;&#10;      &lt;/div&gt;&#13;&#10;    );&#13;&#10;  }&#13;&#10;&#13;&#10;  // 가상화 방식 (100개 초과)&#13;&#10;  return (&#13;&#10;    &lt;VirtualizedAlbumGrid&#13;&#10;      albums={albums}&#13;&#10;      onAlbumClick={onAlbumClick}&#13;&#10;      onEditAlbum={onEditAlbum}&#13;&#10;      onDeleteAlbum={onDeleteAlbum}&#13;&#10;    /&gt;&#13;&#10;  );&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/lib/error-handler.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/lib/error-handler.ts" />
              <option name="updatedContent" value="export class APIError extends Error {&#10;  constructor(&#10;    message: string,&#10;    public status?: number,&#10;    public service?: string,&#10;    public originalError?: unknown&#10;  ) {&#10;    super(message);&#10;    this.name = 'APIError';&#10;  }&#10;}&#10;&#10;export class AuthenticationError extends APIError {&#10;  constructor(service?: string) {&#10;    super(`${service ? `${service} ` : ''}인증이 필요합니다.`, 401, service);&#10;    this.name = 'AuthenticationError';&#10;  }&#10;}&#10;&#10;export class NetworkError extends APIError {&#10;  constructor(service?: string, status?: number, originalError?: unknown) {&#10;    super(`${service ? `${service} ` : ''}네트워크 오류가 발생했습니다.`, status, service, originalError);&#10;    this.name = 'NetworkError';&#10;  }&#10;}&#10;&#10;export class ValidationError extends APIError {&#10;  constructor(message: string, service?: string) {&#10;    super(message, 400, service);&#10;    this.name = 'ValidationError';&#10;  }&#10;}&#10;&#10;export interface ErrorHandlerOptions {&#10;  showToast?: boolean;&#10;  fallbackMessage?: string;&#10;  logError?: boolean;&#10;}&#10;&#10;/**&#10; * API 에러를 일관된 방식으로 처리하는 유틸리티 함수&#10; */&#10;export const handleAPIError = (&#10;  error: unknown, &#10;  service: string,&#10;  options: ErrorHandlerOptions = {}&#10;): APIError =&gt; {&#10;  const { fallbackMessage = '알 수 없는 오류가 발생했습니다.', logError = true } = options;&#10;&#10;  if (logError) {&#10;    console.error(`[${service}] Error:`, error);&#10;  }&#10;&#10;  // 이미 APIError 인스턴스인 경우&#10;  if (error instanceof APIError) {&#10;    return error;&#10;  }&#10;&#10;  // Response 객체인 경우&#10;  if (error instanceof Response) {&#10;    if (error.status === 401) {&#10;      return new AuthenticationError(service);&#10;    }&#10;    return new NetworkError(service, error.status);&#10;  }&#10;&#10;  // 일반 Error 객체인 경우&#10;  if (error instanceof Error) {&#10;    if (error.message.includes('Not authenticated') || error.message.includes('Authentication')) {&#10;      return new AuthenticationError(service);&#10;    }&#10;    if (error.message.includes('Failed to') || error.message.includes('Network')) {&#10;      return new NetworkError(service, undefined, error);&#10;    }&#10;    return new APIError(error.message, undefined, service, error);&#10;  }&#10;&#10;  // 기타 경우&#10;  return new APIError(fallbackMessage, undefined, service, error);&#10;};&#10;&#10;/**&#10; * 환경 변수 누락 에러를 처리하는 유틸리티 함수&#10; */&#10;export const createEnvironmentError = (service: string, requiredVars: string[]): APIError =&gt; {&#10;  const message = `${service} 연동을 위해서는 환경 변수 설정이 필요합니다.&#10;&#10;필요한 환경 변수:&#10;${requiredVars.map(v =&gt; `- ${v}`).join('\n')}&#10;&#10;.env.local 파일에 해당 값들을 설정해주세요.`;&#10;&#10;  return new ValidationError(message, service);&#10;};&#10;&#10;/**&#10; * 사용자 친화적인 에러 메시지를 생성하는 함수&#10; */&#10;export const getUserFriendlyErrorMessage = (error: APIError): string =&gt; {&#10;  if (error instanceof AuthenticationError) {&#10;    return `${error.service || '서비스'} 로그인이 필요합니다. 다시 로그인해주세요.`;&#10;  }&#10;&#10;  if (error instanceof NetworkError) {&#10;    return `${error.service || '서비스'} 연결에 문제가 발생했습니다. 인터넷 연결을 확인하고 다시 시도해주세요.`;&#10;  }&#10;&#10;  if (error instanceof ValidationError) {&#10;    return error.message;&#10;  }&#10;&#10;  return error.message || '알 수 없는 오류가 발생했습니다.';&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/lib/storage-manager.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/lib/storage-manager.ts" />
              <option name="originalContent" value="import { StorageService, StorageProvider, StorageConnection } from '@/types/storage';&#10;import { DropboxService } from '@/services/dropbox';&#10;import { GoogleDriveService } from '@/services/google-drive';&#10;&#10;export class StorageManager {&#10;  private services: Map&lt;StorageProvider, StorageService&gt; = new Map();&#10;  private activeConnection: StorageConnection | null = null;&#10;&#10;  constructor() {&#10;    this.services.set('dropbox', new DropboxService());&#10;    this.services.set('googledrive', new GoogleDriveService());&#10;  }&#10;&#10;  getService(provider: StorageProvider): StorageService | undefined {&#10;    return this.services.get(provider);&#10;  }&#10;&#10;  async connectToProvider(provider: StorageProvider): Promise&lt;StorageConnection&gt; {&#10;    const service = this.getService(provider);&#10;    if (!service) {&#10;      throw new Error(`Unsupported provider: ${provider}`);&#10;    }&#10;&#10;    console.log(' Connecting to provider:', provider);&#10;    const connection = await service.authenticate();&#10;    console.log(' Connection established:', connection);&#10;    &#10;    this.activeConnection = connection;&#10;    &#10;    // Store connection in localStorage for persistence&#10;    localStorage.setItem('storage-connection', JSON.stringify(connection));&#10;    &#10;    // Set access token for Dropbox service&#10;    if (provider === 'dropbox' &amp;&amp; service instanceof DropboxService) {&#10;      (service as { accessToken?: string }).accessToken = connection.accessToken;&#10;    }&#10;    &#10;    return connection;&#10;  }&#10;&#10;  getActiveConnection(): StorageConnection | null {&#10;    if (this.activeConnection) {&#10;      return this.activeConnection;&#10;    }&#10;&#10;    // Try to restore from localStorage&#10;    const stored = localStorage.getItem('storage-connection');&#10;    if (stored) {&#10;      try {&#10;        this.activeConnection = JSON.parse(stored);&#10;        return this.activeConnection;&#10;      } catch (e) {&#10;        console.error('Failed to parse stored connection:', e);&#10;        localStorage.removeItem('storage-connection');&#10;      }&#10;    }&#10;&#10;    return null;&#10;  }&#10;&#10;  disconnect(): void {&#10;    this.activeConnection = null;&#10;    localStorage.removeItem('storage-connection');&#10;  }&#10;&#10;  isConnected(): boolean {&#10;    const connection = this.getActiveConnection();&#10;    if (!connection) return false;&#10;&#10;    // Check if token is expired&#10;    if (connection.expiresAt &amp;&amp; Date.now() &gt; connection.expiresAt) {&#10;      this.disconnect();&#10;      return false;&#10;    }&#10;&#10;    return true;&#10;  }&#10;&#10;  getProviderDisplayName(provider: StorageProvider): string {&#10;    switch (provider) {&#10;      case 'dropbox':&#10;        return 'Dropbox';&#10;      case 'googledrive':&#10;        return 'Google Drive';&#10;      case 'onedrive':&#10;        return 'OneDrive';&#10;      case 'local':&#10;        return '로컬 파일';&#10;      default:&#10;        return provider;&#10;    }&#10;  }&#10;}&#10;&#10;// Singleton instance&#10;export const storageManager = new StorageManager();&#10;" />
              <option name="updatedContent" value="import { StorageService, StorageProvider, StorageConnection } from '@/types/storage';&#10;import { DropboxService } from '@/services/dropbox';&#10;import { GoogleDriveService } from '@/services/google-drive';&#10;&#10;export class StorageManager {&#10;  private services: Map&lt;StorageProvider, StorageService&gt; = new Map();&#10;  private activeConnection: StorageConnection | null = null;&#10;&#10;  constructor() {&#10;    this.services.set('dropbox', new DropboxService());&#10;    this.services.set('googledrive', new GoogleDriveService());&#10;  }&#10;&#10;  getService(provider: StorageProvider): StorageService | undefined {&#10;    return this.services.get(provider);&#10;  }&#10;&#10;  getProviderDisplayName(provider: StorageProvider): string {&#10;    const displayNames: Record&lt;StorageProvider, string&gt; = {&#10;      'local': '로컬 파일',&#10;      'dropbox': 'Dropbox',&#10;      'googledrive': 'Google Drive',&#10;      'onedrive': 'OneDrive'&#10;    };&#10;    return displayNames[provider] || provider;&#10;  }&#10;&#10;  async connectToProvider(provider: StorageProvider): Promise&lt;StorageConnection&gt; {&#10;    const service = this.getService(provider);&#10;    if (!service) {&#10;      throw new Error(`Unsupported provider: ${provider}`);&#10;    }&#10;&#10;    console.log(' Connecting to provider:', provider);&#10;    const connection = await service.authenticate();&#10;    console.log(' Connection established:', connection);&#10;    &#10;    this.activeConnection = connection;&#10;    &#10;    // Store connection in localStorage for persistence&#10;    localStorage.setItem('storage-connection', JSON.stringify(connection));&#10;    &#10;    // Set access token for Dropbox service&#10;    if (provider === 'dropbox' &amp;&amp; service instanceof DropboxService) {&#10;      (service as { accessToken?: string }).accessToken = connection.accessToken;&#10;    }&#10;    &#10;    return connection;&#10;  }&#10;&#10;  getActiveConnection(): StorageConnection | null {&#10;    if (this.activeConnection) {&#10;      return this.activeConnection;&#10;    }&#10;&#10;    // Try to restore from localStorage&#10;    const stored = localStorage.getItem('storage-connection');&#10;    if (stored) {&#10;      try {&#10;        this.activeConnection = JSON.parse(stored);&#10;        return this.activeConnection;&#10;      } catch (e) {&#10;        console.error('Failed to parse stored connection:', e);&#10;        localStorage.removeItem('storage-connection');&#10;      }&#10;    }&#10;&#10;    return null;&#10;  }&#10;&#10;  disconnect(): void {&#10;    this.activeConnection = null;&#10;    localStorage.removeItem('storage-connection');&#10;  }&#10;&#10;  isConnected(): boolean {&#10;    const connection = this.getActiveConnection();&#10;    if (!connection) return false;&#10;&#10;    // Check if token is expired&#10;    if (connection.expiresAt &amp;&amp; Date.now() &gt; connection.expiresAt) {&#10;      this.disconnect();&#10;      return false;&#10;    }&#10;&#10;    return true;&#10;  }&#10;}&#10;&#10;// Singleton instance&#10;export const storageManager = new StorageManager();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/lib/useAsyncState.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/lib/useAsyncState.ts" />
              <option name="originalContent" value="import { useState, useCallback } from 'react';&#10;import { APIError, getUserFriendlyErrorMessage } from './error-handler';&#10;import { toast } from 'sonner';&#10;&#10;export interface AsyncState&lt;T&gt; {&#10;  data: T | null;&#10;  isLoading: boolean;&#10;  error: string | null;&#10;}&#10;&#10;export interface UseAsyncStateOptions {&#10;  showToast?: boolean;&#10;  initialData?: any;&#10;  onSuccess?: (data: any) =&gt; void;&#10;  onError?: (error: APIError) =&gt; void;&#10;}&#10;&#10;/**&#10; * 비동기 작업의 로딩, 성공, 실패 상태를 관리하는 커스텀 훅&#10; */&#10;export function useAsyncState&lt;T = any&gt;(options: UseAsyncStateOptions = {}) {&#10;  const { showToast = true, initialData = null, onSuccess, onError } = options;&#10;&#10;  const [state, setState] = useState&lt;AsyncState&lt;T&gt;&gt;({&#10;    data: initialData,&#10;    isLoading: false,&#10;    error: null,&#10;  });&#10;&#10;  const execute = useCallback(async (asyncFunction: () =&gt; Promise&lt;T&gt;) =&gt; {&#10;    setState(prev =&gt; ({ ...prev, isLoading: true, error: null }));&#10;&#10;    try {&#10;      const result = await asyncFunction();&#10;      setState({&#10;        data: result,&#10;        isLoading: false,&#10;        error: null,&#10;      });&#10;&#10;      if (onSuccess) {&#10;        onSuccess(result);&#10;      }&#10;&#10;      return result;&#10;    } catch (error) {&#10;      const apiError = error instanceof APIError ? error : new APIError('알 수 없는 오류가 발생했습니다.');&#10;      const errorMessage = getUserFriendlyErrorMessage(apiError);&#10;&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        isLoading: false,&#10;        error: errorMessage,&#10;      }));&#10;&#10;      if (showToast) {&#10;        toast.error(errorMessage);&#10;      }&#10;&#10;      if (onError) {&#10;        onError(apiError);&#10;      }&#10;&#10;      throw apiError;&#10;    }&#10;  }, [showToast, onSuccess, onError]);&#10;&#10;  const reset = useCallback(() =&gt; {&#10;    setState({&#10;      data: initialData,&#10;      isLoading: false,&#10;      error: null,&#10;    });&#10;  }, [initialData]);&#10;&#10;  const setData = useCallback((data: T) =&gt; {&#10;    setState(prev =&gt; ({ ...prev, data }));&#10;  }, []);&#10;&#10;  const setError = useCallback((error: string) =&gt; {&#10;    setState(prev =&gt; ({ ...prev, error, isLoading: false }));&#10;  }, []);&#10;&#10;  return {&#10;    ...state,&#10;    execute,&#10;    reset,&#10;    setData,&#10;    setError,&#10;  };&#10;}&#10;&#10;/**&#10; * 파일 업로드/다운로드 등의 작업을 위한 특화된 훅&#10; */&#10;export function useFileOperation() {&#10;  return useAsyncState({&#10;    showToast: true,&#10;    onSuccess: (data) =&gt; {&#10;      if (data &amp;&amp; typeof data === 'object' &amp;&amp; 'message' in data) {&#10;        toast.success(data.message as string);&#10;      }&#10;    },&#10;  });&#10;}&#10;&#10;/**&#10; * API 호출을 위한 특화된 훅&#10; */&#10;export function useApiCall&lt;T = any&gt;(options: UseAsyncStateOptions = {}) {&#10;  return useAsyncState&lt;T&gt;({&#10;    showToast: true,&#10;    ...options,&#10;  });&#10;}&#10;" />
              <option name="updatedContent" value="import { useState, useCallback } from 'react';&#13;&#10;import { APIError, getUserFriendlyErrorMessage } from './error-handler';&#13;&#10;import { toast } from 'sonner';&#13;&#10;&#13;&#10;export interface AsyncState&lt;T&gt; {&#13;&#10;  data: T | null;&#13;&#10;  isLoading: boolean;&#13;&#10;  error: string | null;&#13;&#10;}&#13;&#10;&#13;&#10;export interface UseAsyncStateOptions&lt;T = unknown&gt; {&#13;&#10;  showToast?: boolean;&#13;&#10;  initialData?: T;&#13;&#10;  onSuccess?: (data: T) =&gt; void;&#13;&#10;  onError?: (error: APIError) =&gt; void;&#13;&#10;}&#13;&#10;&#13;&#10;/**&#13;&#10; * 비동기 작업의 로딩, 성공, 실패 상태를 관리하는 커스텀 훅&#13;&#10; */&#13;&#10;export function useAsyncState&lt;T = unknown&gt;(options: UseAsyncStateOptions&lt;T&gt; = {}) {&#13;&#10;  const { showToast = true, initialData = null, onSuccess, onError } = options;&#13;&#10;&#13;&#10;  const [state, setState] = useState&lt;AsyncState&lt;T&gt;&gt;({&#13;&#10;    data: initialData,&#13;&#10;    isLoading: false,&#13;&#10;    error: null,&#13;&#10;  });&#13;&#10;&#13;&#10;  const execute = useCallback(async (asyncFunction: () =&gt; Promise&lt;T&gt;) =&gt; {&#13;&#10;    setState(prev =&gt; ({ ...prev, isLoading: true, error: null }));&#13;&#10;&#13;&#10;    try {&#13;&#10;      const result = await asyncFunction();&#13;&#10;      setState({&#13;&#10;        data: result,&#13;&#10;        isLoading: false,&#13;&#10;        error: null,&#13;&#10;      });&#13;&#10;&#13;&#10;      if (onSuccess) {&#13;&#10;        onSuccess(result);&#13;&#10;      }&#13;&#10;&#13;&#10;      return result;&#13;&#10;    } catch (error) {&#13;&#10;      const apiError = error instanceof APIError ? error : new APIError('알 수 없는 오류가 발생했습니다.');&#13;&#10;      const errorMessage = getUserFriendlyErrorMessage(apiError);&#13;&#10;&#13;&#10;      setState(prev =&gt; ({&#13;&#10;        ...prev,&#13;&#10;        isLoading: false,&#13;&#10;        error: errorMessage,&#13;&#10;      }));&#13;&#10;&#13;&#10;      if (showToast) {&#13;&#10;        toast.error(errorMessage);&#13;&#10;      }&#13;&#10;&#13;&#10;      if (onError) {&#13;&#10;        onError(apiError);&#13;&#10;      }&#13;&#10;&#13;&#10;      throw apiError;&#13;&#10;    }&#13;&#10;  }, [showToast, onSuccess, onError]);&#13;&#10;&#13;&#10;  const reset = useCallback(() =&gt; {&#13;&#10;    setState({&#13;&#10;      data: initialData,&#13;&#10;      isLoading: false,&#13;&#10;      error: null,&#13;&#10;    });&#13;&#10;  }, [initialData]);&#13;&#10;&#13;&#10;  const setData = useCallback((data: T) =&gt; {&#13;&#10;    setState(prev =&gt; ({ ...prev, data }));&#13;&#10;  }, []);&#13;&#10;&#13;&#10;  const setError = useCallback((error: string) =&gt; {&#13;&#10;    setState(prev =&gt; ({ ...prev, error, isLoading: false }));&#13;&#10;  }, []);&#13;&#10;&#13;&#10;  return {&#13;&#10;    ...state,&#13;&#10;    execute,&#13;&#10;    reset,&#13;&#10;    setData,&#13;&#10;    setError,&#13;&#10;  };&#13;&#10;}&#13;&#10;&#13;&#10;/**&#13;&#10; * 파일 업로드/다운로드 등의 작업을 위한 특화된 훅&#13;&#10; */&#13;&#10;export function useFileOperation() {&#13;&#10;  return useAsyncState({&#13;&#10;    showToast: true,&#13;&#10;    onSuccess: (data) =&gt; {&#13;&#10;      if (data &amp;&amp; typeof data === 'object' &amp;&amp; 'message' in data) {&#13;&#10;        toast.success(data.message as string);&#13;&#10;      }&#13;&#10;    },&#13;&#10;  });&#13;&#10;}&#13;&#10;&#13;&#10;/**&#13;&#10; * API 호출을 위한 특화된 훅&#13;&#10; */&#13;&#10;export function useApiCall&lt;T = unknown&gt;(options: UseAsyncStateOptions&lt;T&gt; = {}) {&#13;&#10;  return useAsyncState&lt;T&gt;({&#13;&#10;    showToast: true,&#13;&#10;    ...options,&#13;&#10;  });&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/services/dropbox.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/services/dropbox.ts" />
              <option name="originalContent" value="import { StorageService, StorageConnection, CloudFile, StorageProvider } from '@/types/storage';&#10;import { handleAPIError, createEnvironmentError, AuthenticationError, NetworkError } from '@/lib/error-handler';&#10;&#10;interface DropboxEntry {&#10;  '.tag': string;&#10;  id: string;&#10;  name: string;&#10;  path_display: string;&#10;  size: number;&#10;  client_modified: string;&#10;}&#10;&#10;export class DropboxService implements StorageService {&#10;  public accessToken: string | null = null;&#10;  private readonly clientId = process.env.NEXT_PUBLIC_DROPBOX_CLIENT_ID;&#10;  private readonly redirectUri = process.env.NEXT_PUBLIC_DROPBOX_REDIRECT_URI;&#10;&#10;  async authenticate(): Promise&lt;StorageConnection&gt; {&#10;    if (!this.clientId || !this.redirectUri) {&#10;      throw createEnvironmentError('Dropbox', [&#10;        'NEXT_PUBLIC_DROPBOX_CLIENT_ID',&#10;        'NEXT_PUBLIC_DROPBOX_REDIRECT_URI'&#10;      ]);&#10;    }&#10;&#10;    // OAuth 2.0 flow&#10;    const authUrl = `https://www.dropbox.com/oauth2/authorize?client_id=${this.clientId}&amp;redirect_uri=${encodeURIComponent(this.redirectUri)}&amp;response_type=code&amp;token_access_type=offline`;&#10;    &#10;    // Open popup window for authentication&#10;    const popup = window.open(authUrl, 'dropbox-auth', 'width=500,height=600');&#10;    &#10;    return new Promise((resolve, reject) =&gt; {&#10;      const checkClosed = setInterval(() =&gt; {&#10;        if (popup?.closed) {&#10;          clearInterval(checkClosed);&#10;          reject(new Error('Authentication cancelled'));&#10;        }&#10;      }, 1000);&#10;&#10;      // Listen for message from popup&#10;      const messageHandler = (event: MessageEvent) =&gt; {&#10;        if (event.origin !== window.location.origin) return;&#10;        &#10;        if (event.data.type === 'DROPBOX_AUTH_SUCCESS') {&#10;          clearInterval(checkClosed);&#10;          popup?.close();&#10;          window.removeEventListener('message', messageHandler);&#10;          &#10;          this.accessToken = event.data.accessToken;&#10;          resolve({&#10;            provider: 'dropbox',&#10;            accessToken: event.data.accessToken,&#10;            refreshToken: event.data.refreshToken,&#10;            expiresAt: event.data.expiresAt,&#10;            userId: event.data.userId,&#10;            displayName: event.data.displayName&#10;          });&#10;        } else if (event.data.type === 'DROPBOX_AUTH_ERROR') {&#10;          clearInterval(checkClosed);&#10;          popup?.close();&#10;          window.removeEventListener('message', messageHandler);&#10;          reject(new Error(event.data.error));&#10;        }&#10;      };&#10;&#10;      window.addEventListener('message', messageHandler);&#10;    });&#10;  }&#10;&#10;  async listFiles(path: string = ''): Promise&lt;CloudFile[]&gt; {&#10;    if (!this.accessToken) {&#10;      throw new AuthenticationError('Dropbox');&#10;    }&#10;&#10;    console.log(' Dropbox listFiles called with path:', path, 'token:', this.accessToken ? 'Token exists' : 'No token');&#10;&#10;    try {&#10;      const response = await fetch('/api/dropbox/proxy', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json'&#10;        },&#10;        body: JSON.stringify({&#10;          action: 'list_files',&#10;          data: { path },&#10;          accessToken: this.accessToken&#10;        })&#10;      });&#10;&#10;      console.log(' Dropbox API response status:', response.status);&#10;      &#10;      if (!response.ok) {&#10;        const errorText = await response.text();&#10;        console.error(' Dropbox API error:', errorText);&#10;        throw new NetworkError('Dropbox', response.status);&#10;      }&#10;&#10;      const data = await response.json();&#10;      console.log(' Dropbox API response data:', data);&#10;      console.log(' Total entries found:', data.entries?.length || 0);&#10;      &#10;      if (data.entries) {&#10;        const allFiles = data.entries.filter((entry: DropboxEntry) =&gt; entry['.tag'] === 'file');&#10;        const jsonFiles = allFiles.filter((entry: DropboxEntry) =&gt; entry.name.endsWith('.json'));&#10;        &#10;        console.log(' All files:', allFiles.map((f: DropboxEntry) =&gt; f.name));&#10;        console.log(' JSON files:', jsonFiles.map((f: DropboxEntry) =&gt; f.name));&#10;        &#10;        // 폴더도 보여주기 (디버깅용)&#10;        const folders = data.entries.filter((entry: DropboxEntry) =&gt; entry['.tag'] === 'folder');&#10;        console.log(' Folders found:', folders.map((f: DropboxEntry) =&gt; f.name));&#10;        &#10;        return jsonFiles.map((entry: DropboxEntry) =&gt; ({&#10;          id: entry.path_display, // Use path_display as ID for downloads&#10;          name: entry.name,&#10;          path: entry.path_display,&#10;          size: entry.size,&#10;          modifiedAt: entry.client_modified,&#10;          provider: 'dropbox' as StorageProvider&#10;        }));&#10;      }&#10;      &#10;      console.log(' No entries found in response');&#10;      return [];&#10;    } catch (error) {&#10;      console.error(' Dropbox listFiles error:', error);&#10;      throw handleAPIError(error, 'Dropbox');&#10;    }&#10;  }&#10;&#10;  async getFile(fileId: string): Promise&lt;string&gt; {&#10;    if (!this.accessToken) {&#10;      throw new AuthenticationError('Dropbox');&#10;    }&#10;&#10;    try {&#10;      const response = await fetch('/api/dropbox/proxy', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json'&#10;        },&#10;        body: JSON.stringify({&#10;          action: 'download_file',&#10;          data: { path: fileId },&#10;          accessToken: this.accessToken&#10;        })&#10;      });&#10;&#10;      if (!response.ok) {&#10;        throw new NetworkError('Dropbox', response.status);&#10;      }&#10;&#10;      const result = await response.json();&#10;      return result.content;&#10;    } catch (error) {&#10;      throw handleAPIError(error, 'Dropbox');&#10;    }&#10;  }&#10;&#10;  async saveFile(fileId: string, content: string): Promise&lt;void&gt; {&#10;    if (!this.accessToken) {&#10;      throw new AuthenticationError('Dropbox');&#10;    }&#10;&#10;    try {&#10;      const response = await fetch('/api/dropbox/proxy', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json'&#10;        },&#10;        body: JSON.stringify({&#10;          action: 'upload_file',&#10;          data: {&#10;            path: fileId,&#10;            content: content,&#10;            mode: 'overwrite'&#10;          },&#10;          accessToken: this.accessToken&#10;        })&#10;      });&#10;&#10;      if (!response.ok) {&#10;        throw new NetworkError('Dropbox', response.status);&#10;      }&#10;    } catch (error) {&#10;      throw handleAPIError(error, 'Dropbox');&#10;    }&#10;  }&#10;&#10;  async createFile(name: string, content: string, path: string = ''): Promise&lt;CloudFile&gt; {&#10;    if (!this.accessToken) {&#10;      throw new AuthenticationError('Dropbox');&#10;    }&#10;&#10;    try {&#10;      const filePath = path ? `${path}/${name}` : `/${name}`;&#10;&#10;      const response = await fetch('/api/dropbox/proxy', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json'&#10;        },&#10;        body: JSON.stringify({&#10;          action: 'upload_file',&#10;          data: {&#10;            path: filePath,&#10;            content: content,&#10;            mode: 'add'&#10;          },&#10;          accessToken: this.accessToken&#10;        })&#10;      });&#10;&#10;      if (!response.ok) {&#10;        throw new NetworkError('Dropbox', response.status);&#10;      }&#10;&#10;      const data = await response.json();&#10;      return {&#10;        id: data.path_display,&#10;        name: data.name,&#10;        path: data.path_display,&#10;        size: data.size,&#10;        modifiedAt: data.client_modified,&#10;        provider: 'dropbox'&#10;      };&#10;    } catch (error) {&#10;      throw handleAPIError(error, 'Dropbox');&#10;    }&#10;  }&#10;&#10;  async deleteFile(fileId: string): Promise&lt;void&gt; {&#10;    if (!this.accessToken) {&#10;      throw new AuthenticationError('Dropbox');&#10;    }&#10;&#10;    try {&#10;      const response = await fetch('/api/dropbox/proxy', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json'&#10;        },&#10;        body: JSON.stringify({&#10;          action: 'delete_file',&#10;          data: { path: fileId },&#10;          accessToken: this.accessToken&#10;        })&#10;      });&#10;&#10;      if (!response.ok) {&#10;        throw new NetworkError('Dropbox', response.status);&#10;      }&#10;    } catch (error) {&#10;      throw handleAPIError(error, 'Dropbox');&#10;    }&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { StorageService, StorageConnection, CloudFile, StorageProvider } from '@/types/storage';&#13;&#10;import { handleAPIError, createEnvironmentError, AuthenticationError, NetworkError } from '@/lib/error-handler';&#13;&#10;&#13;&#10;interface DropboxEntry {&#13;&#10;  '.tag': string;&#13;&#10;  id: string;&#13;&#10;  name: string;&#13;&#10;  path_display: string;&#13;&#10;  size: number;&#13;&#10;  client_modified: string;&#13;&#10;}&#13;&#10;&#13;&#10;export class DropboxService implements StorageService {&#13;&#10;  public accessToken: string | null = null;&#13;&#10;  private readonly clientId = process.env.NEXT_PUBLIC_DROPBOX_CLIENT_ID;&#13;&#10;  private readonly redirectUri = process.env.NEXT_PUBLIC_DROPBOX_REDIRECT_URI;&#13;&#10;&#13;&#10;  async authenticate(): Promise&lt;StorageConnection&gt; {&#13;&#10;    console.log(' Dropbox authenticate started');&#13;&#10;    console.log(' Client ID:', this.clientId ? 'Present' : 'Missing');&#13;&#10;    console.log(' Redirect URI:', this.redirectUri ? 'Present' : 'Missing');&#13;&#10;&#13;&#10;    if (!this.clientId || !this.redirectUri) {&#13;&#10;      const error = createEnvironmentError('Dropbox', [&#13;&#10;        'NEXT_PUBLIC_DROPBOX_CLIENT_ID',&#13;&#10;        'NEXT_PUBLIC_DROPBOX_REDIRECT_URI'&#13;&#10;      ]);&#13;&#10;      console.error(' Environment error:', error.message);&#13;&#10;      throw error;&#13;&#10;    }&#13;&#10;&#13;&#10;    try {&#13;&#10;      // OAuth 2.0 flow&#13;&#10;      const authUrl = `https://www.dropbox.com/oauth2/authorize?client_id=${this.clientId}&amp;redirect_uri=${encodeURIComponent(this.redirectUri)}&amp;response_type=code&amp;token_access_type=offline`;&#13;&#10;      console.log(' Opening popup with URL:', authUrl);&#13;&#10;      &#13;&#10;      // Open popup window for authentication&#13;&#10;      const popup = window.open(authUrl, 'dropbox-auth', 'width=500,height=600');&#13;&#10;      &#13;&#10;      if (!popup) {&#13;&#10;        throw new Error('팝업이 차단되었습니다. 팝업 차단을 해제하고 다시 시도해주세요.');&#13;&#10;      }&#13;&#10;&#13;&#10;      console.log(' Popup opened, waiting for callback...');&#13;&#10;      &#13;&#10;      return new Promise((resolve, reject) =&gt; {&#13;&#10;        let isResolved = false;&#13;&#10;&#13;&#10;        const checkClosed = setInterval(() =&gt; {&#13;&#10;          if (popup?.closed &amp;&amp; !isResolved) {&#13;&#10;            console.log(' Popup was closed by user');&#13;&#10;            clearInterval(checkClosed);&#13;&#10;            isResolved = true;&#13;&#10;            reject(new Error('사용자가 인증을 취소했습니다.'));&#13;&#10;          }&#13;&#10;        }, 1000);&#13;&#10;&#13;&#10;        // Listen for message from popup&#13;&#10;        const messageHandler = (event: MessageEvent) =&gt; {&#13;&#10;          console.log(' Received message:', event);&#13;&#10;          console.log(' Message origin:', event.origin);&#13;&#10;          console.log(' Current origin:', window.location.origin);&#13;&#10;          &#13;&#10;          // Origin check - be more flexible for development&#13;&#10;          const validOrigins = [&#13;&#10;            window.location.origin,&#13;&#10;            'http://localhost:3001',&#13;&#10;            'http://127.0.0.1:3001',&#13;&#10;            'http://10.5.0.2:3001' // Add Docker/network origin&#13;&#10;          ];&#13;&#10;          &#13;&#10;          if (!validOrigins.includes(event.origin)) {&#13;&#10;            console.warn(' Message from invalid origin:', event.origin);&#13;&#10;            return;&#13;&#10;          }&#13;&#10;          &#13;&#10;          if (event.data.type === 'DROPBOX_AUTH_SUCCESS') {&#13;&#10;            console.log(' Authentication successful');&#13;&#10;            clearInterval(checkClosed);&#13;&#10;            popup?.close();&#13;&#10;            window.removeEventListener('message', messageHandler);&#13;&#10;            isResolved = true;&#13;&#10;            &#13;&#10;            this.accessToken = event.data.accessToken;&#13;&#10;            resolve({&#13;&#10;              provider: 'dropbox',&#13;&#10;              accessToken: event.data.accessToken,&#13;&#10;              refreshToken: event.data.refreshToken,&#13;&#10;              expiresAt: event.data.expiresAt,&#13;&#10;              userId: event.data.userId,&#13;&#10;              displayName: event.data.displayName&#13;&#10;            });&#13;&#10;          } else if (event.data.type === 'DROPBOX_AUTH_ERROR') {&#13;&#10;            console.error(' Authentication error:', event.data.error);&#13;&#10;            clearInterval(checkClosed);&#13;&#10;            popup?.close();&#13;&#10;            window.removeEventListener('message', messageHandler);&#13;&#10;            isResolved = true;&#13;&#10;            reject(new Error(event.data.error));&#13;&#10;          }&#13;&#10;        };&#13;&#10;&#13;&#10;        window.addEventListener('message', messageHandler);&#13;&#10;&#13;&#10;        // Add timeout to prevent hanging forever&#13;&#10;        setTimeout(() =&gt; {&#13;&#10;          if (!isResolved) {&#13;&#10;            console.error(' Authentication timeout');&#13;&#10;            clearInterval(checkClosed);&#13;&#10;            popup?.close();&#13;&#10;            window.removeEventListener('message', messageHandler);&#13;&#10;            isResolved = true;&#13;&#10;            reject(new Error('인증 시간이 초과되었습니다. 다시 시도해주세요.'));&#13;&#10;          }&#13;&#10;        }, 300000); // 5 minutes timeout&#13;&#10;      });&#13;&#10;    } catch (error) {&#13;&#10;      console.error(' Dropbox authenticate error:', error);&#13;&#10;      throw handleAPIError(error, 'Dropbox');&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  async listFiles(path: string = ''): Promise&lt;CloudFile[]&gt; {&#13;&#10;    if (!this.accessToken) {&#13;&#10;      throw new AuthenticationError('Dropbox');&#13;&#10;    }&#13;&#10;&#13;&#10;    console.log(' Dropbox listFiles called with path:', path, 'token:', this.accessToken ? 'Token exists' : 'No token');&#13;&#10;&#13;&#10;    try {&#13;&#10;      const response = await fetch('/api/dropbox/proxy', {&#13;&#10;        method: 'POST',&#13;&#10;        headers: {&#13;&#10;          'Content-Type': 'application/json'&#13;&#10;        },&#13;&#10;        body: JSON.stringify({&#13;&#10;          action: 'list_files',&#13;&#10;          data: { path },&#13;&#10;          accessToken: this.accessToken&#13;&#10;        })&#13;&#10;      });&#13;&#10;&#13;&#10;      console.log(' Dropbox API response status:', response.status);&#13;&#10;      &#13;&#10;      if (!response.ok) {&#13;&#10;        const errorText = await response.text();&#13;&#10;        console.error(' Dropbox API error:', errorText);&#13;&#10;        throw new NetworkError('Dropbox', response.status);&#13;&#10;      }&#13;&#10;&#13;&#10;      const data = await response.json();&#13;&#10;      console.log(' Dropbox API response data:', data);&#13;&#10;      console.log(' Total entries found:', data.entries?.length || 0);&#13;&#10;      &#13;&#10;      if (data.entries) {&#13;&#10;        const allFiles = data.entries.filter((entry: DropboxEntry) =&gt; entry['.tag'] === 'file');&#13;&#10;        const jsonFiles = allFiles.filter((entry: DropboxEntry) =&gt; entry.name.endsWith('.json'));&#13;&#10;        &#13;&#10;        console.log(' All files:', allFiles.map((f: DropboxEntry) =&gt; f.name));&#13;&#10;        console.log(' JSON files:', jsonFiles.map((f: DropboxEntry) =&gt; f.name));&#13;&#10;        &#13;&#10;        // 폴더도 보여주기 (디버깅용)&#13;&#10;        const folders = data.entries.filter((entry: DropboxEntry) =&gt; entry['.tag'] === 'folder');&#13;&#10;        console.log(' Folders found:', folders.map((f: DropboxEntry) =&gt; f.name));&#13;&#10;        &#13;&#10;        return jsonFiles.map((entry: DropboxEntry) =&gt; ({&#13;&#10;          id: entry.path_display, // Use path_display as ID for downloads&#13;&#10;          name: entry.name,&#13;&#10;          path: entry.path_display,&#13;&#10;          size: entry.size,&#13;&#10;          modifiedAt: entry.client_modified,&#13;&#10;          provider: 'dropbox' as StorageProvider&#13;&#10;        }));&#13;&#10;      }&#13;&#10;      &#13;&#10;      console.log(' No entries found in response');&#13;&#10;      return [];&#13;&#10;    } catch (error) {&#13;&#10;      console.error(' Dropbox listFiles error:', error);&#13;&#10;      throw handleAPIError(error, 'Dropbox');&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  async getFile(fileId: string): Promise&lt;string&gt; {&#13;&#10;    if (!this.accessToken) {&#13;&#10;      throw new AuthenticationError('Dropbox');&#13;&#10;    }&#13;&#10;&#13;&#10;    try {&#13;&#10;      const response = await fetch('/api/dropbox/proxy', {&#13;&#10;        method: 'POST',&#13;&#10;        headers: {&#13;&#10;          'Content-Type': 'application/json'&#13;&#10;        },&#13;&#10;        body: JSON.stringify({&#13;&#10;          action: 'download_file',&#13;&#10;          data: { path: fileId },&#13;&#10;          accessToken: this.accessToken&#13;&#10;        })&#13;&#10;      });&#13;&#10;&#13;&#10;      if (!response.ok) {&#13;&#10;        throw new NetworkError('Dropbox', response.status);&#13;&#10;      }&#13;&#10;&#13;&#10;      const result = await response.json();&#13;&#10;      return result.content;&#13;&#10;    } catch (error) {&#13;&#10;      throw handleAPIError(error, 'Dropbox');&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  async saveFile(fileId: string, content: string): Promise&lt;void&gt; {&#13;&#10;    if (!this.accessToken) {&#13;&#10;      throw new AuthenticationError('Dropbox');&#13;&#10;    }&#13;&#10;&#13;&#10;    try {&#13;&#10;      const response = await fetch('/api/dropbox/proxy', {&#13;&#10;        method: 'POST',&#13;&#10;        headers: {&#13;&#10;          'Content-Type': 'application/json'&#13;&#10;        },&#13;&#10;        body: JSON.stringify({&#13;&#10;          action: 'upload_file',&#13;&#10;          data: {&#13;&#10;            path: fileId,&#13;&#10;            content: content,&#13;&#10;            mode: 'overwrite'&#13;&#10;          },&#13;&#10;          accessToken: this.accessToken&#13;&#10;        })&#13;&#10;      });&#13;&#10;&#13;&#10;      if (!response.ok) {&#13;&#10;        throw new NetworkError('Dropbox', response.status);&#13;&#10;      }&#13;&#10;    } catch (error) {&#13;&#10;      throw handleAPIError(error, 'Dropbox');&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  async createFile(name: string, content: string, path: string = ''): Promise&lt;CloudFile&gt; {&#13;&#10;    if (!this.accessToken) {&#13;&#10;      throw new AuthenticationError('Dropbox');&#13;&#10;    }&#13;&#10;&#13;&#10;    try {&#13;&#10;      const filePath = path ? `${path}/${name}` : `/${name}`;&#13;&#10;&#13;&#10;      const response = await fetch('/api/dropbox/proxy', {&#13;&#10;        method: 'POST',&#13;&#10;        headers: {&#13;&#10;          'Content-Type': 'application/json'&#13;&#10;        },&#13;&#10;        body: JSON.stringify({&#13;&#10;          action: 'upload_file',&#13;&#10;          data: {&#13;&#10;            path: filePath,&#13;&#10;            content: content,&#13;&#10;            mode: 'add'&#13;&#10;          },&#13;&#10;          accessToken: this.accessToken&#13;&#10;        })&#13;&#10;      });&#13;&#10;&#13;&#10;      if (!response.ok) {&#13;&#10;        throw new NetworkError('Dropbox', response.status);&#13;&#10;      }&#13;&#10;&#13;&#10;      const data = await response.json();&#13;&#10;      return {&#13;&#10;        id: data.path_display,&#13;&#10;        name: data.name,&#13;&#10;        path: data.path_display,&#13;&#10;        size: data.size,&#13;&#10;        modifiedAt: data.client_modified,&#13;&#10;        provider: 'dropbox'&#13;&#10;      };&#13;&#10;    } catch (error) {&#13;&#10;      throw handleAPIError(error, 'Dropbox');&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  async deleteFile(fileId: string): Promise&lt;void&gt; {&#13;&#10;    if (!this.accessToken) {&#13;&#10;      throw new AuthenticationError('Dropbox');&#13;&#10;    }&#13;&#10;&#13;&#10;    try {&#13;&#10;      const response = await fetch('/api/dropbox/proxy', {&#13;&#10;        method: 'POST',&#13;&#10;        headers: {&#13;&#10;          'Content-Type': 'application/json'&#13;&#10;        },&#13;&#10;        body: JSON.stringify({&#13;&#10;          action: 'delete_file',&#13;&#10;          data: { path: fileId },&#13;&#10;          accessToken: this.accessToken&#13;&#10;        })&#13;&#10;      });&#13;&#10;&#13;&#10;      if (!response.ok) {&#13;&#10;        throw new NetworkError('Dropbox', response.status);&#13;&#10;      }&#13;&#10;    } catch (error) {&#13;&#10;      throw handleAPIError(error, 'Dropbox');&#13;&#10;    }&#13;&#10;  }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/services/google-drive.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/services/google-drive.ts" />
              <option name="originalContent" value="import { StorageService, StorageConnection, CloudFile, StorageProvider } from '@/types/storage';&#10;import { handleAPIError, createEnvironmentError, AuthenticationError, NetworkError } from '@/lib/error-handler';&#10;&#10;export class GoogleDriveService implements StorageService {&#10;  public accessToken: string | null = null;&#10;  private readonly clientId = process.env.NEXT_PUBLIC_GOOGLE_CLIENT_ID;&#10;  private readonly redirectUri = process.env.NEXT_PUBLIC_GOOGLE_REDIRECT_URI;&#10;&#10;  async authenticate(): Promise&lt;StorageConnection&gt; {&#10;    if (!this.clientId || !this.redirectUri) {&#10;      throw createEnvironmentError('Google Drive', [&#10;        'NEXT_PUBLIC_GOOGLE_CLIENT_ID',&#10;        'NEXT_PUBLIC_GOOGLE_REDIRECT_URI'&#10;      ]);&#10;    }&#10;&#10;    // OAuth 2.0 flow&#10;    const authUrl = `https://accounts.google.com/o/oauth2/v2/auth?client_id=${this.clientId}&amp;redirect_uri=${encodeURIComponent(this.redirectUri)}&amp;response_type=code&amp;scope=${encodeURIComponent('https://www.googleapis.com/auth/drive.file')}&amp;access_type=offline&amp;prompt=consent`;&#10;    &#10;    // Open popup window for authentication&#10;    const popup = window.open(authUrl, 'google-auth', 'width=500,height=600');&#10;    &#10;    return new Promise((resolve, reject) =&gt; {&#10;      const checkClosed = setInterval(() =&gt; {&#10;        if (popup?.closed) {&#10;          clearInterval(checkClosed);&#10;          reject(new Error('Authentication cancelled'));&#10;        }&#10;      }, 1000);&#10;&#10;      // Listen for message from popup&#10;      const messageHandler = (event: MessageEvent) =&gt; {&#10;        if (event.origin !== window.location.origin) return;&#10;        &#10;        if (event.data.type === 'GOOGLE_AUTH_SUCCESS') {&#10;          clearInterval(checkClosed);&#10;          popup?.close();&#10;          window.removeEventListener('message', messageHandler);&#10;          &#10;          this.accessToken = event.data.accessToken;&#10;          resolve({&#10;            provider: 'googledrive',&#10;            accessToken: event.data.accessToken,&#10;            refreshToken: event.data.refreshToken,&#10;            expiresAt: event.data.expiresAt,&#10;            userId: event.data.userId,&#10;            displayName: event.data.displayName&#10;          });&#10;        } else if (event.data.type === 'GOOGLE_AUTH_ERROR') {&#10;          clearInterval(checkClosed);&#10;          popup?.close();&#10;          window.removeEventListener('message', messageHandler);&#10;          reject(new Error(event.data.error));&#10;        }&#10;      };&#10;&#10;      window.addEventListener('message', messageHandler);&#10;    });&#10;  }&#10;&#10;  async listFiles(path: string = ''): Promise&lt;CloudFile[]&gt; {&#10;    if (!this.accessToken) {&#10;      throw new AuthenticationError('Google Drive');&#10;    }&#10;&#10;    console.log(' Google Drive listFiles called with token:', this.accessToken ? 'Token exists' : 'No token');&#10;&#10;    try {&#10;      const response = await fetch('/api/google/proxy', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json'&#10;        },&#10;        body: JSON.stringify({&#10;          action: 'list_files',&#10;          data: { path },&#10;          accessToken: this.accessToken&#10;        })&#10;      });&#10;&#10;      console.log(' Google Drive API response status:', response.status);&#10;      &#10;      if (!response.ok) {&#10;        const errorText = await response.text();&#10;        console.error(' Google Drive API error:', errorText);&#10;        throw new NetworkError('Google Drive', response.status);&#10;      }&#10;&#10;      const data = await response.json();&#10;      console.log(' Google Drive API response data:', data);&#10;      &#10;      if (data.files) {&#10;        const jsonFiles = data.files.filter((file: { name: string }) =&gt; file.name.endsWith('.json'));&#10;        console.log(' JSON files found:', jsonFiles.map((f: { name: string }) =&gt; f.name));&#10;        console.log(' File details:', jsonFiles.map((f: { id: string; name: string }) =&gt; ({ id: f.id, name: f.name })));&#10;        &#10;        return jsonFiles.map((file: { id: string; name: string; size?: string; modifiedTime?: string }) =&gt; ({&#10;          id: file.id,&#10;          name: file.name,&#10;          path: `/${file.name}`,&#10;          size: parseInt(file.size || '0') || 0,&#10;          modifiedAt: file.modifiedTime,&#10;          provider: 'googledrive' as StorageProvider&#10;        }));&#10;      }&#10;      &#10;      console.log(' No files found in response');&#10;      return [];&#10;    } catch (error) {&#10;      console.error(' Google Drive listFiles error:', error);&#10;      throw handleAPIError(error, 'Google Drive');&#10;    }&#10;  }&#10;&#10;  async getFile(fileId: string): Promise&lt;string&gt; {&#10;    if (!this.accessToken) {&#10;      throw new AuthenticationError('Google Drive');&#10;    }&#10;&#10;    try {&#10;      const response = await fetch('/api/google/proxy', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json'&#10;        },&#10;        body: JSON.stringify({&#10;          action: 'download_file',&#10;          data: { fileId },&#10;          accessToken: this.accessToken&#10;        })&#10;      });&#10;&#10;      if (!response.ok) {&#10;        throw new NetworkError('Google Drive', response.status);&#10;      }&#10;&#10;      const result = await response.json();&#10;      return result.content;&#10;    } catch (error) {&#10;      throw handleAPIError(error, 'Google Drive');&#10;    }&#10;  }&#10;&#10;  async saveFile(fileId: string, content: string): Promise&lt;void&gt; {&#10;    if (!this.accessToken) {&#10;      throw new AuthenticationError('Google Drive');&#10;    }&#10;&#10;    try {&#10;      const response = await fetch('/api/google/proxy', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json'&#10;        },&#10;        body: JSON.stringify({&#10;          action: 'update_file',&#10;          data: {&#10;            fileId,&#10;            content: content&#10;          },&#10;          accessToken: this.accessToken&#10;        })&#10;      });&#10;&#10;      if (!response.ok) {&#10;        throw new NetworkError('Google Drive', response.status);&#10;      }&#10;    } catch (error) {&#10;      throw handleAPIError(error, 'Google Drive');&#10;    }&#10;  }&#10;&#10;  async createFile(name: string, content: string, path: string = ''): Promise&lt;CloudFile&gt; {&#10;    if (!this.accessToken) {&#10;      throw new AuthenticationError('Google Drive');&#10;    }&#10;&#10;    try {&#10;      const response = await fetch('/api/google/proxy', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json'&#10;        },&#10;        body: JSON.stringify({&#10;          action: 'upload_file',&#10;          data: {&#10;            fileName: name,&#10;            content: content,&#10;            parentId: path&#10;          },&#10;          accessToken: this.accessToken&#10;        })&#10;      });&#10;&#10;      if (!response.ok) {&#10;        throw new NetworkError('Google Drive', response.status);&#10;      }&#10;&#10;      const data = await response.json();&#10;      return {&#10;        id: data.id,&#10;        name: data.name,&#10;        path: `/${data.name}`,&#10;        size: parseInt(data.size) || 0,&#10;        modifiedAt: data.modifiedTime,&#10;        provider: 'googledrive'&#10;      };&#10;    } catch (error) {&#10;      throw handleAPIError(error, 'Google Drive');&#10;    }&#10;  }&#10;&#10;  async deleteFile(fileId: string): Promise&lt;void&gt; {&#10;    if (!this.accessToken) {&#10;      throw new AuthenticationError('Google Drive');&#10;    }&#10;&#10;    try {&#10;      const response = await fetch('/api/google/proxy', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json'&#10;        },&#10;        body: JSON.stringify({&#10;          action: 'delete_file',&#10;          data: { fileId },&#10;          accessToken: this.accessToken&#10;        })&#10;      });&#10;&#10;      if (!response.ok) {&#10;        throw new NetworkError('Google Drive', response.status);&#10;      }&#10;    } catch (error) {&#10;      throw handleAPIError(error, 'Google Drive');&#10;    }&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { StorageService, StorageConnection, CloudFile, StorageProvider } from '@/types/storage';&#13;&#10;import { handleAPIError, createEnvironmentError, AuthenticationError, NetworkError } from '@/lib/error-handler';&#13;&#10;&#13;&#10;export class GoogleDriveService implements StorageService {&#13;&#10;  public accessToken: string | null = null;&#13;&#10;  private readonly clientId = process.env.NEXT_PUBLIC_GOOGLE_CLIENT_ID;&#13;&#10;  private readonly redirectUri = process.env.NEXT_PUBLIC_GOOGLE_REDIRECT_URI;&#13;&#10;&#13;&#10;  async authenticate(): Promise&lt;StorageConnection&gt; {&#13;&#10;    console.log(' Google Drive authenticate started');&#13;&#10;    console.log(' Client ID:', this.clientId ? 'Present' : 'Missing');&#13;&#10;    console.log(' Redirect URI:', this.redirectUri ? 'Present' : 'Missing');&#13;&#10;&#13;&#10;    if (!this.clientId || !this.redirectUri) {&#13;&#10;      const error = createEnvironmentError('Google Drive', [&#13;&#10;        'NEXT_PUBLIC_GOOGLE_CLIENT_ID',&#13;&#10;        'NEXT_PUBLIC_GOOGLE_REDIRECT_URI'&#13;&#10;      ]);&#13;&#10;      console.error(' Environment error:', error.message);&#13;&#10;      throw error;&#13;&#10;    }&#13;&#10;&#13;&#10;    try {&#13;&#10;      // OAuth 2.0 flow&#13;&#10;      const authUrl = `https://accounts.google.com/o/oauth2/v2/auth?client_id=${this.clientId}&amp;redirect_uri=${encodeURIComponent(this.redirectUri)}&amp;response_type=code&amp;scope=${encodeURIComponent('https://www.googleapis.com/auth/drive.file')}&amp;access_type=offline&amp;prompt=consent`;&#13;&#10;      console.log(' Opening popup with URL:', authUrl);&#13;&#10;      &#13;&#10;      // Open popup window for authentication&#13;&#10;      const popup = window.open(authUrl, 'google-auth', 'width=500,height=600');&#13;&#10;      &#13;&#10;      if (!popup) {&#13;&#10;        throw new Error('팝업이 차단되었습니다. 팝업 차단을 해제하고 다시 시도해주세요.');&#13;&#10;      }&#13;&#10;&#13;&#10;      console.log(' Popup opened, waiting for callback...');&#13;&#10;      &#13;&#10;      return new Promise((resolve, reject) =&gt; {&#13;&#10;        let isResolved = false;&#13;&#10;        let checkClosedInterval: NodeJS.Timeout | null = null;&#13;&#10;&#13;&#10;        // Google의 COOP 정책으로 인해 window.closed 체크가 불가능할 수 있으므로&#13;&#10;        // 더 관대한 방식으로 팝업 상태를 체크합니다&#13;&#10;        const checkClosed = () =&gt; {&#13;&#10;          try {&#13;&#10;            // popup.closed 접근을 시도하되, 실패해도 계속 진행&#13;&#10;            if (popup?.closed &amp;&amp; !isResolved) {&#13;&#10;              console.log(' Popup was closed by user');&#13;&#10;              if (checkClosedInterval) {&#13;&#10;                clearInterval(checkClosedInterval);&#13;&#10;                checkClosedInterval = null;&#13;&#10;              }&#13;&#10;              isResolved = true;&#13;&#10;              reject(new Error('사용자가 인증을 취소했습니다.'));&#13;&#10;            }&#13;&#10;          } catch (error) {&#13;&#10;            // Cross-Origin-Opener-Policy로 인한 에러는 무시&#13;&#10;            console.log(' Cannot check popup.closed due to COOP policy - this is normal for Google OAuth');&#13;&#10;          }&#13;&#10;        };&#13;&#10;&#13;&#10;        // 1초마다 팝업 상태 체크 (에러가 발생해도 계속 진행)&#13;&#10;        checkClosedInterval = setInterval(checkClosed, 1000);&#13;&#10;&#13;&#10;        // Listen for message from popup&#13;&#10;        const messageHandler = (event: MessageEvent) =&gt; {&#13;&#10;          console.log(' Received message:', event);&#13;&#10;          console.log(' Message origin:', event.origin);&#13;&#10;          console.log(' Current origin:', window.location.origin);&#13;&#10;          &#13;&#10;          // Origin check - be more flexible for development&#13;&#10;          const validOrigins = [&#13;&#10;            window.location.origin,&#13;&#10;            'http://localhost:3001',&#13;&#10;            'http://127.0.0.1:3001',&#13;&#10;            'http://10.5.0.2:3001' // Add Docker/network origin&#13;&#10;          ];&#13;&#10;          &#13;&#10;          if (!validOrigins.includes(event.origin)) {&#13;&#10;            console.warn(' Message from invalid origin:', event.origin);&#13;&#10;            return;&#13;&#10;          }&#13;&#10;          &#13;&#10;          if (event.data.type === 'GOOGLE_AUTH_SUCCESS') {&#13;&#10;            console.log(' Authentication successful');&#13;&#10;            if (checkClosedInterval) {&#13;&#10;              clearInterval(checkClosedInterval);&#13;&#10;              checkClosedInterval = null;&#13;&#10;            }&#13;&#10;            popup?.close();&#13;&#10;            window.removeEventListener('message', messageHandler);&#13;&#10;            isResolved = true;&#13;&#10;            &#13;&#10;            this.accessToken = event.data.accessToken;&#13;&#10;            resolve({&#13;&#10;              provider: 'googledrive',&#13;&#10;              accessToken: event.data.accessToken,&#13;&#10;              refreshToken: event.data.refreshToken,&#13;&#10;              expiresAt: event.data.expiresAt,&#13;&#10;              userId: event.data.userId,&#13;&#10;              displayName: event.data.displayName&#13;&#10;            });&#13;&#10;          } else if (event.data.type === 'GOOGLE_AUTH_ERROR') {&#13;&#10;            console.error(' Authentication error:', event.data.error);&#13;&#10;            if (checkClosedInterval) {&#13;&#10;              clearInterval(checkClosedInterval);&#13;&#10;              checkClosedInterval = null;&#13;&#10;            }&#13;&#10;            popup?.close();&#13;&#10;            window.removeEventListener('message', messageHandler);&#13;&#10;            isResolved = true;&#13;&#10;            reject(new Error(event.data.error));&#13;&#10;          }&#13;&#10;        };&#13;&#10;&#13;&#10;        window.addEventListener('message', messageHandler);&#13;&#10;&#13;&#10;        // Add timeout to prevent hanging forever (5 minutes)&#13;&#10;        setTimeout(() =&gt; {&#13;&#10;          if (!isResolved) {&#13;&#10;            console.error(' Authentication timeout');&#13;&#10;            if (checkClosedInterval) {&#13;&#10;              clearInterval(checkClosedInterval);&#13;&#10;              checkClosedInterval = null;&#13;&#10;            }&#13;&#10;            popup?.close();&#13;&#10;            window.removeEventListener('message', messageHandler);&#13;&#10;            isResolved = true;&#13;&#10;            reject(new Error('인증 시간이 초과되었습니다. 다시 시도해주세요.'));&#13;&#10;          }&#13;&#10;        }, 300000); // 5 minutes timeout&#13;&#10;      });&#13;&#10;    } catch (error) {&#13;&#10;      console.error(' Google Drive authenticate error:', error);&#13;&#10;      throw handleAPIError(error, 'Google Drive');&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  async listFiles(path: string = ''): Promise&lt;CloudFile[]&gt; {&#13;&#10;    if (!this.accessToken) {&#13;&#10;      throw new AuthenticationError('Google Drive');&#13;&#10;    }&#13;&#10;&#13;&#10;    console.log(' Google Drive listFiles called with token:', this.accessToken ? 'Token exists' : 'No token');&#13;&#10;&#13;&#10;    try {&#13;&#10;      const response = await fetch('/api/google/proxy', {&#13;&#10;        method: 'POST',&#13;&#10;        headers: {&#13;&#10;          'Content-Type': 'application/json'&#13;&#10;        },&#13;&#10;        body: JSON.stringify({&#13;&#10;          action: 'list_files',&#13;&#10;          data: { path },&#13;&#10;          accessToken: this.accessToken&#13;&#10;        })&#13;&#10;      });&#13;&#10;&#13;&#10;      console.log(' Google Drive API response status:', response.status);&#13;&#10;      &#13;&#10;      if (!response.ok) {&#13;&#10;        const errorText = await response.text();&#13;&#10;        console.error(' Google Drive API error:', errorText);&#13;&#10;        throw new NetworkError('Google Drive', response.status);&#13;&#10;      }&#13;&#10;&#13;&#10;      const data = await response.json();&#13;&#10;      console.log(' Google Drive API response data:', data);&#13;&#10;      &#13;&#10;      if (data.files) {&#13;&#10;        const jsonFiles = data.files.filter((file: { name: string }) =&gt; file.name.endsWith('.json'));&#13;&#10;        console.log(' JSON files found:', jsonFiles.map((f: { name: string }) =&gt; f.name));&#13;&#10;        console.log(' File details:', jsonFiles.map((f: { id: string; name: string }) =&gt; ({ id: f.id, name: f.name })));&#13;&#10;        &#13;&#10;        return jsonFiles.map((file: { id: string; name: string; size?: string; modifiedTime?: string }) =&gt; ({&#13;&#10;          id: file.id,&#13;&#10;          name: file.name,&#13;&#10;          path: `/${file.name}`,&#13;&#10;          size: parseInt(file.size || '0') || 0,&#13;&#10;          modifiedAt: file.modifiedTime,&#13;&#10;          provider: 'googledrive' as StorageProvider&#13;&#10;        }));&#13;&#10;      }&#13;&#10;      &#13;&#10;      console.log(' No files found in response');&#13;&#10;      return [];&#13;&#10;    } catch (error) {&#13;&#10;      console.error(' Google Drive listFiles error:', error);&#13;&#10;      throw handleAPIError(error, 'Google Drive');&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  async getFile(fileId: string): Promise&lt;string&gt; {&#13;&#10;    if (!this.accessToken) {&#13;&#10;      throw new AuthenticationError('Google Drive');&#13;&#10;    }&#13;&#10;&#13;&#10;    try {&#13;&#10;      const response = await fetch('/api/google/proxy', {&#13;&#10;        method: 'POST',&#13;&#10;        headers: {&#13;&#10;          'Content-Type': 'application/json'&#13;&#10;        },&#13;&#10;        body: JSON.stringify({&#13;&#10;          action: 'download_file',&#13;&#10;          data: { fileId },&#13;&#10;          accessToken: this.accessToken&#13;&#10;        })&#13;&#10;      });&#13;&#10;&#13;&#10;      if (!response.ok) {&#13;&#10;        throw new NetworkError('Google Drive', response.status);&#13;&#10;      }&#13;&#10;&#13;&#10;      const result = await response.json();&#13;&#10;      return result.content;&#13;&#10;    } catch (error) {&#13;&#10;      throw handleAPIError(error, 'Google Drive');&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  async saveFile(fileId: string, content: string): Promise&lt;void&gt; {&#13;&#10;    if (!this.accessToken) {&#13;&#10;      throw new AuthenticationError('Google Drive');&#13;&#10;    }&#13;&#10;&#13;&#10;    try {&#13;&#10;      const response = await fetch('/api/google/proxy', {&#13;&#10;        method: 'POST',&#13;&#10;        headers: {&#13;&#10;          'Content-Type': 'application/json'&#13;&#10;        },&#13;&#10;        body: JSON.stringify({&#13;&#10;          action: 'update_file',&#13;&#10;          data: {&#13;&#10;            fileId,&#13;&#10;            content: content&#13;&#10;          },&#13;&#10;          accessToken: this.accessToken&#13;&#10;        })&#13;&#10;      });&#13;&#10;&#13;&#10;      if (!response.ok) {&#13;&#10;        throw new NetworkError('Google Drive', response.status);&#13;&#10;      }&#13;&#10;    } catch (error) {&#13;&#10;      throw handleAPIError(error, 'Google Drive');&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  async createFile(name: string, content: string, path: string = ''): Promise&lt;CloudFile&gt; {&#13;&#10;    if (!this.accessToken) {&#13;&#10;      throw new AuthenticationError('Google Drive');&#13;&#10;    }&#13;&#10;&#13;&#10;    try {&#13;&#10;      const response = await fetch('/api/google/proxy', {&#13;&#10;        method: 'POST',&#13;&#10;        headers: {&#13;&#10;          'Content-Type': 'application/json'&#13;&#10;        },&#13;&#10;        body: JSON.stringify({&#13;&#10;          action: 'upload_file',&#13;&#10;          data: {&#13;&#10;            fileName: name,&#13;&#10;            content: content,&#13;&#10;            parentId: path&#13;&#10;          },&#13;&#10;          accessToken: this.accessToken&#13;&#10;        })&#13;&#10;      });&#13;&#10;&#13;&#10;      if (!response.ok) {&#13;&#10;        throw new NetworkError('Google Drive', response.status);&#13;&#10;      }&#13;&#10;&#13;&#10;      const data = await response.json();&#13;&#10;      return {&#13;&#10;        id: data.id,&#13;&#10;        name: data.name,&#13;&#10;        path: `/${data.name}`,&#13;&#10;        size: parseInt(data.size) || 0,&#13;&#10;        modifiedAt: data.modifiedTime,&#13;&#10;        provider: 'googledrive'&#13;&#10;      };&#13;&#10;    } catch (error) {&#13;&#10;      throw handleAPIError(error, 'Google Drive');&#13;&#10;    }&#13;&#10;  }&#13;&#10;&#13;&#10;  async deleteFile(fileId: string): Promise&lt;void&gt; {&#13;&#10;    if (!this.accessToken) {&#13;&#10;      throw new AuthenticationError('Google Drive');&#13;&#10;    }&#13;&#10;&#13;&#10;    try {&#13;&#10;      const response = await fetch('/api/google/proxy', {&#13;&#10;        method: 'POST',&#13;&#10;        headers: {&#13;&#10;          'Content-Type': 'application/json'&#13;&#10;        },&#13;&#10;        body: JSON.stringify({&#13;&#10;          action: 'delete_file',&#13;&#10;          data: { fileId },&#13;&#10;          accessToken: this.accessToken&#13;&#10;        })&#13;&#10;      });&#13;&#10;&#13;&#10;      if (!response.ok) {&#13;&#10;        throw new NetworkError('Google Drive', response.status);&#13;&#10;      }&#13;&#10;    } catch (error) {&#13;&#10;      throw handleAPIError(error, 'Google Drive');&#13;&#10;    }&#13;&#10;  }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>