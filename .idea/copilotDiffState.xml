<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/app/auth/dropbox/callback/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/auth/dropbox/callback/page.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;import { Suspense, useEffect } from 'react';&#10;import { useSearchParams } from 'next/navigation';&#10;&#10;function DropboxCallbackContent() {&#10;  const searchParams = useSearchParams();&#10;&#10;  useEffect(() =&gt; {&#10;    const code = searchParams.get('code');&#10;    const error = searchParams.get('error');&#10;&#10;    // 부모 창의 origin을 가져오기 (더 안전한 방법)&#10;    const getParentOrigin = () =&gt; {&#10;      try {&#10;        return window.opener?.location.origin || '*';&#10;      } catch (e) {&#10;        // Cross-origin 접근 불가 시 와일드카드 사용 (보안상 주의)&#10;        return '*';&#10;      }&#10;    };&#10;&#10;    if (error) {&#10;      // Send error to parent window&#10;      const targetOrigin = getParentOrigin();&#10;      window.opener?.postMessage({&#10;        type: 'DROPBOX_AUTH_ERROR',&#10;        error: error&#10;      }, targetOrigin);&#10;      window.close();&#10;      return;&#10;    }&#10;&#10;    if (code) {&#10;      // Exchange code for access token&#10;      exchangeCodeForToken(code);&#10;    }&#10;  }, [searchParams]);&#10;&#10;  const exchangeCodeForToken = async (code: string) =&gt; {&#10;    try {&#10;      const response = await fetch('/api/auth/dropbox/token', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json',&#10;        },&#10;        body: JSON.stringify({ code })&#10;      });&#10;&#10;      if (!response.ok) {&#10;        throw new Error('Token exchange failed');&#10;      }&#10;&#10;      const tokenData = await response.json();&#10;      &#10;      // 부모 창의 origin을 가져오기&#10;      const getParentOrigin = () =&gt; {&#10;        try {&#10;          return window.opener?.location.origin || '*';&#10;        } catch (e) {&#10;          return '*';&#10;        }&#10;      };&#10;&#10;      const targetOrigin = getParentOrigin();&#10;&#10;      // Send success data to parent window&#10;      window.opener?.postMessage({&#10;        type: 'DROPBOX_AUTH_SUCCESS',&#10;        accessToken: tokenData.access_token,&#10;        refreshToken: tokenData.refresh_token,&#10;        expiresAt: Date.now() + (tokenData.expires_in * 1000),&#10;        userId: tokenData.account_id,&#10;        displayName: tokenData.account_id // Dropbox doesn't provide display name in token response&#10;      }, targetOrigin);&#10;&#10;      window.close();&#10;    } catch (error) {&#10;      console.error('Token exchange error:', error);&#10;&#10;      const getParentOrigin = () =&gt; {&#10;        try {&#10;          return window.opener?.location.origin || '*';&#10;        } catch (e) {&#10;          return '*';&#10;        }&#10;      };&#10;&#10;      const targetOrigin = getParentOrigin();&#10;&#10;      window.opener?.postMessage({&#10;        type: 'DROPBOX_AUTH_ERROR',&#10;        error: 'Token exchange failed'&#10;      }, targetOrigin);&#10;      window.close();&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;flex min-h-screen items-center justify-center p-8&quot;&gt;&#10;      &lt;div className=&quot;text-center&quot;&gt;&#10;        &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;Dropbox 인증 중...&lt;/h1&gt;&#10;        &lt;p className=&quot;text-zinc-600&quot;&gt;인증을 처리하고 있습니다. 잠시만 기다려주세요.&lt;/p&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;export default function DropboxCallback() {&#10;  return (&#10;    &lt;Suspense fallback={&#10;      &lt;div className=&quot;flex min-h-screen items-center justify-center p-8&quot;&gt;&#10;        &lt;div className=&quot;text-center&quot;&gt;&#10;          &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;로딩 중...&lt;/h1&gt;&#10;          &lt;p className=&quot;text-zinc-600&quot;&gt;잠시만 기다려주세요.&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    }&gt;&#10;      &lt;DropboxCallbackContent /&gt;&#10;    &lt;/Suspense&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#13;&#10;&#13;&#10;import { Suspense, useEffect } from 'react';&#13;&#10;import { useSearchParams } from 'next/navigation';&#13;&#10;&#13;&#10;function DropboxCallbackContent() {&#13;&#10;  const searchParams = useSearchParams();&#13;&#10;&#13;&#10;  useEffect(() =&gt; {&#13;&#10;    const code = searchParams.get('code');&#13;&#10;    const error = searchParams.get('error');&#13;&#10;&#13;&#10;    // 부모 창의 origin을 가져오기 (더 안전한 방법)&#13;&#10;    const getParentOrigin = () =&gt; {&#13;&#10;      try {&#13;&#10;        return window.opener?.location.origin || '*';&#13;&#10;      } catch {&#13;&#10;        // Cross-origin 접근 불가 시 와일드카드 사용 (보안상 주의)&#13;&#10;        return '*';&#13;&#10;      }&#13;&#10;    };&#13;&#10;&#13;&#10;    if (error) {&#13;&#10;      // Send error to parent window&#13;&#10;      const targetOrigin = getParentOrigin();&#13;&#10;      window.opener?.postMessage({&#13;&#10;        type: 'DROPBOX_AUTH_ERROR',&#13;&#10;        error: error&#13;&#10;      }, targetOrigin);&#13;&#10;      window.close();&#13;&#10;      return;&#13;&#10;    }&#13;&#10;&#13;&#10;    if (code) {&#13;&#10;      // Exchange code for access token&#13;&#10;      exchangeCodeForToken(code);&#13;&#10;    }&#13;&#10;  }, [searchParams]);&#13;&#10;&#13;&#10;  const exchangeCodeForToken = async (code: string) =&gt; {&#13;&#10;    try {&#13;&#10;      const response = await fetch('/api/auth/dropbox/token', {&#13;&#10;        method: 'POST',&#13;&#10;        headers: {&#13;&#10;          'Content-Type': 'application/json',&#13;&#10;        },&#13;&#10;        body: JSON.stringify({ code })&#13;&#10;      });&#13;&#10;&#13;&#10;      if (!response.ok) {&#13;&#10;        throw new Error('Token exchange failed');&#13;&#10;      }&#13;&#10;&#13;&#10;      const tokenData = await response.json();&#13;&#10;      &#13;&#10;      // 부모 창의 origin을 가져오기&#13;&#10;      const getParentOrigin = () =&gt; {&#13;&#10;        try {&#13;&#10;          return window.opener?.location.origin || '*';&#13;&#10;        } catch {&#13;&#10;          return '*';&#13;&#10;        }&#13;&#10;      };&#13;&#10;&#13;&#10;      const targetOrigin = getParentOrigin();&#13;&#10;&#13;&#10;      // Send success data to parent window&#13;&#10;      window.opener?.postMessage({&#13;&#10;        type: 'DROPBOX_AUTH_SUCCESS',&#13;&#10;        accessToken: tokenData.access_token,&#13;&#10;        refreshToken: tokenData.refresh_token,&#13;&#10;        expiresAt: Date.now() + (tokenData.expires_in * 1000),&#13;&#10;        userId: tokenData.account_id,&#13;&#10;        displayName: tokenData.account_id // Dropbox doesn't provide display name in token response&#13;&#10;      }, targetOrigin);&#13;&#10;&#13;&#10;      window.close();&#13;&#10;    } catch (error) {&#13;&#10;      console.error('Token exchange error:', error);&#13;&#10;&#13;&#10;      const getParentOrigin = () =&gt; {&#13;&#10;        try {&#13;&#10;          return window.opener?.location.origin || '*';&#13;&#10;        } catch {&#13;&#10;          return '*';&#13;&#10;        }&#13;&#10;      };&#13;&#10;&#13;&#10;      const targetOrigin = getParentOrigin();&#13;&#10;&#13;&#10;      window.opener?.postMessage({&#13;&#10;        type: 'DROPBOX_AUTH_ERROR',&#13;&#10;        error: 'Token exchange failed'&#13;&#10;      }, targetOrigin);&#13;&#10;      window.close();&#13;&#10;    }&#13;&#10;  };&#13;&#10;&#13;&#10;  return (&#13;&#10;    &lt;div className=&quot;flex min-h-screen items-center justify-center p-8&quot;&gt;&#13;&#10;      &lt;div className=&quot;text-center&quot;&gt;&#13;&#10;        &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;Dropbox 인증 중...&lt;/h1&gt;&#13;&#10;        &lt;p className=&quot;text-zinc-600&quot;&gt;인증을 처리하고 있습니다. 잠시만 기다려주세요.&lt;/p&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    &lt;/div&gt;&#13;&#10;  );&#13;&#10;}&#13;&#10;&#13;&#10;export default function DropboxCallback() {&#13;&#10;  return (&#13;&#10;    &lt;Suspense fallback={&#13;&#10;      &lt;div className=&quot;flex min-h-screen items-center justify-center p-8&quot;&gt;&#13;&#10;        &lt;div className=&quot;text-center&quot;&gt;&#13;&#10;          &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;로딩 중...&lt;/h1&gt;&#13;&#10;          &lt;p className=&quot;text-zinc-600&quot;&gt;잠시만 기다려주세요.&lt;/p&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    }&gt;&#13;&#10;      &lt;DropboxCallbackContent /&gt;&#13;&#10;    &lt;/Suspense&gt;&#13;&#10;  );&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/auth/google/callback/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/auth/google/callback/page.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;import { useEffect, Suspense } from 'react';&#10;import { useSearchParams } from 'next/navigation';&#10;&#10;function GoogleCallbackContent() {&#10;  const searchParams = useSearchParams();&#10;&#10;  useEffect(() =&gt; {&#10;    const code = searchParams.get('code');&#10;    const error = searchParams.get('error');&#10;&#10;    // 부모 창의 origin을 가져오는 안전한 방법&#10;    const getParentOrigin = () =&gt; {&#10;      try {&#10;        return window.opener?.location.origin || '*';&#10;      } catch (e) {&#10;        // Cross-origin 접근 불가 시 와일드카드 사용&#10;        return '*';&#10;      }&#10;    };&#10;&#10;    if (error) {&#10;      // OAuth 에러 처리&#10;      const targetOrigin = getParentOrigin();&#10;      window.opener?.postMessage({&#10;        type: 'GOOGLE_AUTH_ERROR',&#10;        error: error&#10;      }, targetOrigin);&#10;      window.close();&#10;      return;&#10;    }&#10;&#10;    if (code) {&#10;      // Authorization code를 access token으로 교환&#10;      fetch('/api/auth/google/token', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json'&#10;        },&#10;        body: JSON.stringify({ code })&#10;      })&#10;      .then(response =&gt; response.json())&#10;      .then(data =&gt; {&#10;        const targetOrigin = getParentOrigin();&#10;&#10;        if (data.error) {&#10;          window.opener?.postMessage({&#10;            type: 'GOOGLE_AUTH_ERROR',&#10;            error: data.error&#10;          }, targetOrigin);&#10;        } else {&#10;          // 성공적으로 토큰을 받았을 때&#10;          window.opener?.postMessage({&#10;            type: 'GOOGLE_AUTH_SUCCESS',&#10;            accessToken: data.access_token,&#10;            refreshToken: data.refresh_token,&#10;            expiresAt: Date.now() + (data.expires_in * 1000),&#10;            userId: data.user_id,&#10;            displayName: data.display_name&#10;          }, targetOrigin);&#10;        }&#10;        window.close();&#10;      })&#10;      .catch(error =&gt; {&#10;        console.error('Token exchange error:', error);&#10;        const targetOrigin = getParentOrigin();&#10;        window.opener?.postMessage({&#10;          type: 'GOOGLE_AUTH_ERROR',&#10;          error: 'Token exchange failed'&#10;        }, targetOrigin);&#10;        window.close();&#10;      });&#10;    }&#10;  }, [searchParams]);&#10;&#10;  return (&#10;    &lt;div className=&quot;flex items-center justify-center min-h-screen&quot;&gt;&#10;      &lt;div className=&quot;text-center&quot;&gt;&#10;        &lt;h2 className=&quot;text-lg font-semibold mb-2&quot;&gt;Google Drive 인증 중...&lt;/h2&gt;&#10;        &lt;p className=&quot;text-zinc-600&quot;&gt;잠시만 기다려주세요.&lt;/p&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;export default function GoogleCallbackPage() {&#10;  return (&#10;    &lt;Suspense fallback={&#10;      &lt;div className=&quot;flex items-center justify-center min-h-screen&quot;&gt;&#10;        &lt;div className=&quot;text-center&quot;&gt;&#10;          &lt;h2 className=&quot;text-lg font-semibold mb-2&quot;&gt;로딩 중...&lt;/h2&gt;&#10;          &lt;p className=&quot;text-zinc-600&quot;&gt;잠시만 기다려주세요.&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    }&gt;&#10;      &lt;GoogleCallbackContent /&gt;&#10;    &lt;/Suspense&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;&#10;import { useEffect, Suspense } from 'react';&#10;import { useSearchParams } from 'next/navigation';&#10;&#10;function GoogleCallbackContent() {&#10;  const searchParams = useSearchParams();&#10;&#10;  useEffect(() =&gt; {&#10;    const code = searchParams.get('code');&#10;    const error = searchParams.get('error');&#10;&#10;    // 부모 창의 origin을 가져오는 안전한 방법&#10;    const getParentOrigin = () =&gt; {&#10;      try {&#10;        return window.opener?.location.origin || '*';&#10;      } catch {&#10;        // Cross-origin 접근 불가 시 와일드카드 사용&#10;        return '*';&#10;      }&#10;    };&#10;&#10;    if (error) {&#10;      // OAuth 에러 처리&#10;      const targetOrigin = getParentOrigin();&#10;      window.opener?.postMessage({&#10;        type: 'GOOGLE_AUTH_ERROR',&#10;        error: error&#10;      }, targetOrigin);&#10;      window.close();&#10;      return;&#10;    }&#10;&#10;    if (code) {&#10;      // Authorization code를 access token으로 교환&#10;      fetch('/api/auth/google/token', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json'&#10;        },&#10;        body: JSON.stringify({ code })&#10;      })&#10;      .then(response =&gt; response.json())&#10;      .then(data =&gt; {&#10;        const targetOrigin = getParentOrigin();&#10;&#10;        if (data.error) {&#10;          window.opener?.postMessage({&#10;            type: 'GOOGLE_AUTH_ERROR',&#10;            error: data.error&#10;          }, targetOrigin);&#10;        } else {&#10;          // 성공적으로 토큰을 받았을 때&#10;          window.opener?.postMessage({&#10;            type: 'GOOGLE_AUTH_SUCCESS',&#10;            accessToken: data.access_token,&#10;            refreshToken: data.refresh_token,&#10;            expiresAt: Date.now() + (data.expires_in * 1000),&#10;            userId: data.user_id,&#10;            displayName: data.display_name&#10;          }, targetOrigin);&#10;        }&#10;        window.close();&#10;      })&#10;      .catch(error =&gt; {&#10;        console.error('Token exchange error:', error);&#10;        const targetOrigin = getParentOrigin();&#10;        window.opener?.postMessage({&#10;          type: 'GOOGLE_AUTH_ERROR',&#10;          error: 'Token exchange failed'&#10;        }, targetOrigin);&#10;        window.close();&#10;      });&#10;    }&#10;  }, [searchParams]);&#10;&#10;  return (&#10;    &lt;div className=&quot;flex items-center justify-center min-h-screen&quot;&gt;&#10;      &lt;div className=&quot;text-center&quot;&gt;&#10;        &lt;h2 className=&quot;text-lg font-semibold mb-2&quot;&gt;Google Drive 인증 중...&lt;/h2&gt;&#10;        &lt;p className=&quot;text-zinc-600&quot;&gt;잠시만 기다려주세요.&lt;/p&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;&#10;export default function GoogleCallbackPage() {&#10;  return (&#10;    &lt;Suspense fallback={&#10;      &lt;div className=&quot;flex items-center justify-center min-h-screen&quot;&gt;&#10;        &lt;div className=&quot;text-center&quot;&gt;&#10;          &lt;h2 className=&quot;text-lg font-semibold mb-2&quot;&gt;로딩 중...&lt;/h2&gt;&#10;          &lt;p className=&quot;text-zinc-600&quot;&gt;잠시만 기다려주세요.&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    }&gt;&#10;      &lt;GoogleCallbackContent /&gt;&#10;    &lt;/Suspense&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/__tests__/album-card.test.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/__tests__/album-card.test.tsx" />
              <option name="originalContent" value="import { render, screen, fireEvent, waitFor } from '@testing-library/react';&#10;import { AlbumCard } from '../album-card';&#10;import type { Album } from '@/types/album';&#10;&#10;// Mock Next.js Image component&#10;jest.mock('next/image', () =&gt; {&#10;  return function MockImage(props: any) {&#10;    return &lt;img {...props} /&gt;;&#10;  };&#10;});&#10;&#10;// Mock album images utility&#10;jest.mock('@/lib/album-images', () =&gt; ({&#10;  getPrimaryCoverImage: jest.fn(),&#10;}));&#10;&#10;const mockAlbum: Album = {&#10;  id: '1',&#10;  artist: 'Test Artist',&#10;  title: 'Test Album',&#10;  type: 'Vinyl',&#10;  isFavorite: false,&#10;  createdAt: '2024-01-01T00:00:00Z',&#10;  updatedAt: '2024-01-01T00:00:00Z',&#10;  releaseDate: '2024',&#10;  coverImageUrl: 'https://example.com/cover.jpg',&#10;};&#10;&#10;const mockFavoriteAlbum: Album = {&#10;  ...mockAlbum,&#10;  id: '2',&#10;  isFavorite: true,&#10;};&#10;&#10;describe('AlbumCard', () =&gt; {&#10;  const mockOnClick = jest.fn();&#10;  const mockOnDelete = jest.fn();&#10;&#10;  beforeEach(() =&gt; {&#10;    jest.clearAllMocks();&#10;    require('@/lib/album-images').getPrimaryCoverImage.mockReturnValue('https://example.com/cover.jpg');&#10;  });&#10;&#10;  it('renders album information correctly', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    expect(screen.getByText('Test Artist')).toBeInTheDocument();&#10;    expect(screen.getByText('Test Album')).toBeInTheDocument();&#10;    expect(screen.getByText('2024')).toBeInTheDocument();&#10;  });&#10;&#10;  it('shows favorite star for favorite albums', () =&gt; {&#10;    render(&lt;AlbumCard album={mockFavoriteAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const starIcon = screen.getByRole('button', { name: /test album 상세 보기/i }).querySelector('svg');&#10;    expect(starIcon).toBeInTheDocument();&#10;  });&#10;&#10;  it('does not show favorite star for non-favorite albums', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const cardButton = screen.getByRole('button', { name: /test album 상세 보기/i });&#10;    const starIcon = cardButton.querySelector('.text-yellow-400');&#10;    expect(starIcon).not.toBeInTheDocument();&#10;  });&#10;&#10;  it('calls onClick when card is clicked', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const card = screen.getByRole('button', { name: /test album 상세 보기/i });&#10;    fireEvent.click(card);&#10;&#10;    expect(mockOnClick).toHaveBeenCalledWith();&#10;  });&#10;&#10;  it('calls onClick when Enter key is pressed', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const card = screen.getByRole('button', { name: /test album 상세 보기/i });&#10;    fireEvent.keyDown(card, { key: 'Enter' });&#10;&#10;    expect(mockOnClick).toHaveBeenCalledWith();&#10;  });&#10;&#10;  it('calls onClick when Space key is pressed', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const card = screen.getByRole('button', { name: /test album 상세 보기/i });&#10;    fireEvent.keyDown(card, { key: ' ' });&#10;&#10;    expect(mockOnClick).toHaveBeenCalledWith();&#10;  });&#10;&#10;  it('calls onDelete when delete button is clicked', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const deleteButton = screen.getByRole('button', { name: /앨범 삭제/i });&#10;    fireEvent.click(deleteButton);&#10;&#10;    expect(mockOnDelete).toHaveBeenCalledWith();&#10;    expect(mockOnClick).not.toHaveBeenCalled(); // Should not trigger card click&#10;  });&#10;&#10;  it('shows loading state for images', async () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    // Initially should show loading state (pulse animation)&#10;    const imageContainer = screen.getByText('Test Album').closest('.min-h-\\[200px\\]');&#10;    expect(imageContainer).toBeInTheDocument();&#10;  });&#10;&#10;  it('shows &quot;No Image&quot; when no cover image is available', () =&gt; {&#10;    require('@/lib/album-images').getPrimaryCoverImage.mockReturnValue(null);&#10;&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    expect(screen.getByText('No Image')).toBeInTheDocument();&#10;  });&#10;&#10;  it('handles image loading error gracefully', async () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const image = screen.getByAltText('Test Album');&#10;    fireEvent.error(image);&#10;&#10;    await waitFor(() =&gt; {&#10;      expect(screen.getByText('No Image')).toBeInTheDocument();&#10;    });&#10;  });&#10;&#10;  it('has proper accessibility attributes', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const card = screen.getByRole('button', { name: /test album 상세 보기/i });&#10;    expect(card).toHaveAttribute('tabIndex', '0');&#10;    expect(card).toHaveAttribute('aria-label', 'Test Album 상세 보기');&#10;&#10;    const deleteButton = screen.getByRole('button', { name: /앨범 삭제/i });&#10;    expect(deleteButton).toHaveAttribute('aria-label', '앨범 삭제');&#10;    expect(deleteButton).toHaveAttribute('tabIndex', '0');&#10;  });&#10;&#10;  it('shows title and artist with proper truncation', () =&gt; {&#10;    const longTitleAlbum: Album = {&#10;      ...mockAlbum,&#10;      title: 'This is a very long album title that should be truncated',&#10;      artist: 'This is a very long artist name that should also be truncated',&#10;    };&#10;&#10;    render(&lt;AlbumCard album={longTitleAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const titleElement = screen.getByText(longTitleAlbum.title);&#10;    const artistElement = screen.getByText(longTitleAlbum.artist);&#10;&#10;    expect(titleElement).toHaveClass('truncate');&#10;    expect(artistElement).toHaveClass('truncate');&#10;    expect(titleElement).toHaveAttribute('title', longTitleAlbum.title);&#10;    expect(artistElement).toHaveAttribute('title', longTitleAlbum.artist);&#10;  });&#10;});&#10;" />
              <option name="updatedContent" value="import { render, screen, fireEvent, waitFor } from '@testing-library/react';&#10;import { AlbumCard } from '../album-card';&#10;import type { Album } from '@/types/album';&#10;import { getPrimaryCoverImage } from '@/lib/album-images';&#10;&#10;// Mock Next.js Image component&#10;jest.mock('next/image', () =&gt; {&#10;  return function MockImage(props: React.ImgHTMLAttributes&lt;HTMLImageElement&gt;) {&#10;    // eslint-disable-next-line @next/next/no-img-element, jsx-a11y/alt-text&#10;    return &lt;img {...props} data-testid=&quot;mock-image&quot; /&gt;;&#10;  };&#10;});&#10;&#10;// Mock album images utility&#10;jest.mock('@/lib/album-images', () =&gt; ({&#10;  getPrimaryCoverImage: jest.fn(),&#10;}));&#10;&#10;const mockGetPrimaryCoverImage = getPrimaryCoverImage as jest.MockedFunction&lt;typeof getPrimaryCoverImage&gt;;&#10;&#10;const mockAlbum: Album = {&#10;  id: '1',&#10;  artist: 'Test Artist',&#10;  title: 'Test Album',&#10;  type: 'Vinyl',&#10;  isFavorite: false,&#10;  createdAt: '2024-01-01T00:00:00Z',&#10;  updatedAt: '2024-01-01T00:00:00Z',&#10;  releaseDate: '2024',&#10;  coverImageUrl: 'https://example.com/cover.jpg',&#10;};&#10;&#10;const mockFavoriteAlbum: Album = {&#10;  ...mockAlbum,&#10;  id: '2',&#10;  isFavorite: true,&#10;};&#10;&#10;describe('AlbumCard', () =&gt; {&#10;  const mockOnClick = jest.fn();&#10;  const mockOnDelete = jest.fn();&#10;&#10;  beforeEach(() =&gt; {&#10;    jest.clearAllMocks();&#10;    mockGetPrimaryCoverImage.mockReturnValue('https://example.com/cover.jpg');&#10;  });&#10;&#10;  it('renders album information correctly', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    expect(screen.getByText('Test Artist')).toBeInTheDocument();&#10;    expect(screen.getByText('Test Album')).toBeInTheDocument();&#10;    expect(screen.getByText('2024')).toBeInTheDocument();&#10;  });&#10;&#10;  it('shows favorite star for favorite albums', () =&gt; {&#10;    render(&lt;AlbumCard album={mockFavoriteAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const starIcon = screen.getByRole('button', { name: /test album 상세 보기/i }).querySelector('svg');&#10;    expect(starIcon).toBeInTheDocument();&#10;  });&#10;&#10;  it('does not show favorite star for non-favorite albums', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const cardButton = screen.getByRole('button', { name: /test album 상세 보기/i });&#10;    const starIcon = cardButton.querySelector('.text-yellow-400');&#10;    expect(starIcon).not.toBeInTheDocument();&#10;  });&#10;&#10;  it('calls onClick when card is clicked', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const card = screen.getByRole('button', { name: /test album 상세 보기/i });&#10;    fireEvent.click(card);&#10;&#10;    expect(mockOnClick).toHaveBeenCalledWith();&#10;  });&#10;&#10;  it('calls onClick when Enter key is pressed', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const card = screen.getByRole('button', { name: /test album 상세 보기/i });&#10;    fireEvent.keyDown(card, { key: 'Enter' });&#10;&#10;    expect(mockOnClick).toHaveBeenCalledWith();&#10;  });&#10;&#10;  it('calls onClick when Space key is pressed', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const card = screen.getByRole('button', { name: /test album 상세 보기/i });&#10;    fireEvent.keyDown(card, { key: ' ' });&#10;&#10;    expect(mockOnClick).toHaveBeenCalledWith();&#10;  });&#10;&#10;  it('calls onDelete when delete button is clicked', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const deleteButton = screen.getByRole('button', { name: /앨범 삭제/i });&#10;    fireEvent.click(deleteButton);&#10;&#10;    expect(mockOnDelete).toHaveBeenCalledWith();&#10;    expect(mockOnClick).not.toHaveBeenCalled(); // Should not trigger card click&#10;  });&#10;&#10;  it('shows loading state for images', async () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    // Initially should show loading state (pulse animation)&#10;    const imageContainer = screen.getByText('Test Album').closest('.min-h-\\[200px\\]');&#10;    expect(imageContainer).toBeInTheDocument();&#10;  });&#10;&#10;  it('shows &quot;No Image&quot; when no cover image is available', () =&gt; {&#10;    mockGetPrimaryCoverImage.mockReturnValue(null);&#10;    &#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    expect(screen.getByText('No Image')).toBeInTheDocument();&#10;  });&#10;&#10;  it('handles image loading error gracefully', async () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const image = screen.getByAltText('Test Album');&#10;    fireEvent.error(image);&#10;&#10;    await waitFor(() =&gt; {&#10;      expect(screen.getByText('No Image')).toBeInTheDocument();&#10;    });&#10;  });&#10;&#10;  it('has proper accessibility attributes', () =&gt; {&#10;    render(&lt;AlbumCard album={mockAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const card = screen.getByRole('button', { name: /test album 상세 보기/i });&#10;    expect(card).toHaveAttribute('tabIndex', '0');&#10;    expect(card).toHaveAttribute('aria-label', 'Test Album 상세 보기');&#10;&#10;    const deleteButton = screen.getByRole('button', { name: /앨범 삭제/i });&#10;    expect(deleteButton).toHaveAttribute('aria-label', '앨범 삭제');&#10;    expect(deleteButton).toHaveAttribute('tabIndex', '0');&#10;  });&#10;&#10;  it('shows title and artist with proper truncation', () =&gt; {&#10;    const longTitleAlbum: Album = {&#10;      ...mockAlbum,&#10;      title: 'This is a very long album title that should be truncated',&#10;      artist: 'This is a very long artist name that should also be truncated',&#10;    };&#10;&#10;    render(&lt;AlbumCard album={longTitleAlbum} onClick={mockOnClick} onDelete={mockOnDelete} /&gt;);&#10;&#10;    const titleElement = screen.getByText(longTitleAlbum.title);&#10;    const artistElement = screen.getByText(longTitleAlbum.artist);&#10;&#10;    expect(titleElement).toHaveClass('truncate');&#10;    expect(artistElement).toHaveClass('truncate');&#10;    expect(titleElement).toHaveAttribute('title', longTitleAlbum.title);&#10;    expect(artistElement).toHaveAttribute('title', longTitleAlbum.artist);&#10;  });&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/album-grid.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/album-grid.tsx" />
              <option name="originalContent" value="import * as React from &quot;react&quot;;&#10;import type { Album } from &quot;@/types/album&quot;;&#10;import { AlbumCard } from &quot;@/components/album-card&quot;;&#10;&#10;interface AlbumGridProps {&#10;  albums: Album[];&#10;  onAlbumClick?: (album: Album) =&gt; void;&#10;  onEditAlbum?: (album: Album) =&gt; void;&#10;  onDeleteAlbum?: (album: Album) =&gt; void;&#10;}&#10;&#10;export function AlbumGrid({ albums, onAlbumClick, onEditAlbum, onDeleteAlbum }: AlbumGridProps) {&#10;  if (albums.length === 0) {&#10;    return &lt;div className=&quot;text-zinc-400 text-center py-8&quot;&gt;등록된 앨범이 없습니다.&lt;/div&gt;;&#10;  }&#10;  return (&#10;    &lt;div className=&quot;grid grid-cols-1 xs:grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-3 sm:gap-4 md:gap-6 w-full&quot;&gt;&#10;      {albums.map((album) =&gt; (&#10;        &lt;AlbumCard&#10;          key={album.id}&#10;          album={album}&#10;          onClick={() =&gt; onAlbumClick?.(album)}&#10;          onDelete={() =&gt; onDeleteAlbum?.(album)}&#10;          onEdit={() =&gt; onEditAlbum?.(album)}&#10;        /&gt;&#10;      ))}&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="// 기존 album-grid.tsx를 가상화된 버전으로 교체&#10;export { AlbumGrid, VirtualizedAlbumGrid } from './virtualized-album-grid';" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/error-boundary.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/error-boundary.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;import React, { Component, ErrorInfo, ReactNode } from 'react';&#10;import { APIError } from '@/lib/error-handler';&#10;import { Button } from '@/components/ui/button';&#10;import { AlertTriangle, RefreshCw, Home } from 'lucide-react';&#10;&#10;interface Props {&#10;  children: ReactNode;&#10;  fallback?: ReactNode;&#10;  onError?: (error: Error, errorInfo: ErrorInfo) =&gt; void;&#10;}&#10;&#10;interface State {&#10;  hasError: boolean;&#10;  error: Error | null;&#10;  errorInfo: ErrorInfo | null;&#10;}&#10;&#10;export class ErrorBoundary extends Component&lt;Props, State&gt; {&#10;  constructor(props: Props) {&#10;    super(props);&#10;    this.state = { hasError: false, error: null, errorInfo: null };&#10;  }&#10;&#10;  static getDerivedStateFromError(error: Error): State {&#10;    return {&#10;      hasError: true,&#10;      error,&#10;      errorInfo: null,&#10;    };&#10;  }&#10;&#10;  componentDidCatch(error: Error, errorInfo: ErrorInfo) {&#10;    console.error('ErrorBoundary caught an error:', error, errorInfo);&#10;&#10;    this.setState({&#10;      error,&#10;      errorInfo,&#10;    });&#10;&#10;    // 사용자 정의 에러 핸들러 호출&#10;    if (this.props.onError) {&#10;      this.props.onError(error, errorInfo);&#10;    }&#10;&#10;    // 에러 로깅 (실제 서비스에서는 에러 리포팅 서비스로 전송)&#10;    this.logErrorToService(error, errorInfo);&#10;  }&#10;&#10;  private logErrorToService = (error: Error, errorInfo: ErrorInfo) =&gt; {&#10;    // 여기서 실제 에러 리포팅 서비스(Sentry, LogRocket 등)로 전송할 수 있습니다&#10;    console.log('Error logged:', {&#10;      error: error.message,&#10;      stack: error.stack,&#10;      componentStack: errorInfo.componentStack,&#10;      timestamp: new Date().toISOString(),&#10;    });&#10;  };&#10;&#10;  private handleReload = () =&gt; {&#10;    window.location.reload();&#10;  };&#10;&#10;  private handleGoHome = () =&gt; {&#10;    window.location.href = '/';&#10;  };&#10;&#10;  private handleRetry = () =&gt; {&#10;    this.setState({ hasError: false, error: null, errorInfo: null });&#10;  };&#10;&#10;  render() {&#10;    if (this.state.hasError) {&#10;      // 사용자 정의 fallback UI가 있으면 사용&#10;      if (this.props.fallback) {&#10;        return this.props.fallback;&#10;      }&#10;&#10;      // 기본 에러 UI&#10;      return (&#10;        &lt;div className=&quot;min-h-screen flex items-center justify-center bg-gray-50 dark:bg-zinc-900&quot;&gt;&#10;          &lt;div className=&quot;max-w-md w-full bg-white dark:bg-zinc-800 rounded-lg shadow-lg p-6 border border-gray-200 dark:border-zinc-700&quot;&gt;&#10;            &lt;div className=&quot;flex items-center justify-center w-12 h-12 mx-auto bg-red-100 dark:bg-red-900/20 rounded-full mb-4&quot;&gt;&#10;              &lt;AlertTriangle className=&quot;w-6 h-6 text-red-600 dark:text-red-400&quot; /&gt;&#10;            &lt;/div&gt;&#10;&#10;            &lt;h1 className=&quot;text-xl font-semibold text-gray-900 dark:text-gray-100 text-center mb-2&quot;&gt;&#10;              앗, 문제가 발생했습니다!&#10;            &lt;/h1&gt;&#10;&#10;            &lt;p className=&quot;text-gray-600 dark:text-gray-300 text-center mb-6&quot;&gt;&#10;              예상치 못한 오류가 발생했습니다. 페이지를 새로고침하거나 홈으로 돌아가 보세요.&#10;            &lt;/p&gt;&#10;&#10;            {/* 개발 환경에서만 에러 세부 정보 표시 */}&#10;            {process.env.NODE_ENV === 'development' &amp;&amp; this.state.error &amp;&amp; (&#10;              &lt;details className=&quot;mb-4 p-3 bg-gray-100 dark:bg-zinc-700 rounded text-sm&quot;&gt;&#10;                &lt;summary className=&quot;cursor-pointer font-medium text-gray-700 dark:text-gray-300&quot;&gt;&#10;                  에러 세부 정보 (개발 모드)&#10;                &lt;/summary&gt;&#10;                &lt;div className=&quot;mt-2 text-red-600 dark:text-red-400 font-mono text-xs whitespace-pre-wrap&quot;&gt;&#10;                  {this.state.error.message}&#10;                  {this.state.error.stack &amp;&amp; (&#10;                    &lt;div className=&quot;mt-2 opacity-75&quot;&gt;&#10;                      {this.state.error.stack}&#10;                    &lt;/div&gt;&#10;                  )}&#10;                &lt;/div&gt;&#10;              &lt;/details&gt;&#10;            )}&#10;&#10;            &lt;div className=&quot;flex flex-col sm:flex-row gap-3&quot;&gt;&#10;              &lt;Button&#10;                onClick={this.handleRetry}&#10;                className=&quot;flex-1 flex items-center justify-center gap-2&quot;&#10;                variant=&quot;outline&quot;&#10;              &gt;&#10;                &lt;RefreshCw className=&quot;w-4 h-4&quot; /&gt;&#10;                다시 시도&#10;              &lt;/Button&gt;&#10;&#10;              &lt;Button&#10;                onClick={this.handleReload}&#10;                className=&quot;flex-1 flex items-center justify-center gap-2&quot;&#10;                variant=&quot;outline&quot;&#10;              &gt;&#10;                &lt;RefreshCw className=&quot;w-4 h-4&quot; /&gt;&#10;                새로고침&#10;              &lt;/Button&gt;&#10;&#10;              &lt;Button&#10;                onClick={this.handleGoHome}&#10;                className=&quot;flex-1 flex items-center justify-center gap-2&quot;&#10;              &gt;&#10;                &lt;Home className=&quot;w-4 h-4&quot; /&gt;&#10;                홈으로&#10;              &lt;/Button&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      );&#10;    }&#10;&#10;    return this.props.children;&#10;  }&#10;}&#10;&#10;// 특정 컴포넌트를 위한 간단한 에러 바운더리 HOC&#10;export function withErrorBoundary&lt;P extends object&gt;(&#10;  Component: React.ComponentType&lt;P&gt;,&#10;  fallback?: ReactNode&#10;) {&#10;  const WrappedComponent = (props: P) =&gt; (&#10;    &lt;ErrorBoundary fallback={fallback}&gt;&#10;      &lt;Component {...props} /&gt;&#10;    &lt;/ErrorBoundary&gt;&#10;  );&#10;&#10;  WrappedComponent.displayName = `withErrorBoundary(${Component.displayName || Component.name})`;&#10;  return WrappedComponent;&#10;}&#10;&#10;// 함수형 컴포넌트를 위한 훅&#10;export function useErrorHandler() {&#10;  return (error: Error, errorInfo?: any) =&gt; {&#10;    console.error('Manual error report:', error, errorInfo);&#10;&#10;    // 여기서 에러 리포팅 서비스로 전송&#10;    if (typeof window !== 'undefined') {&#10;      // 실제 구현에서는 에러 서비스 API 호출&#10;      console.log('Error reported to service:', {&#10;        error: error.message,&#10;        stack: error.stack,&#10;        userAgent: navigator.userAgent,&#10;        url: window.location.href,&#10;        timestamp: new Date().toISOString(),&#10;        additionalInfo: errorInfo,&#10;      });&#10;    }&#10;  };&#10;}&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#13;&#10;&#13;&#10;import React, { Component, ErrorInfo, ReactNode } from 'react';&#13;&#10;import { Button } from '@/components/ui/button';&#13;&#10;import { AlertTriangle, RefreshCw, Home } from 'lucide-react';&#13;&#10;&#13;&#10;interface Props {&#13;&#10;  children: ReactNode;&#13;&#10;  fallback?: ReactNode;&#13;&#10;  onError?: (error: Error, errorInfo: ErrorInfo) =&gt; void;&#13;&#10;}&#13;&#10;&#13;&#10;interface State {&#13;&#10;  hasError: boolean;&#13;&#10;  error: Error | null;&#13;&#10;  errorInfo: ErrorInfo | null;&#13;&#10;}&#13;&#10;&#13;&#10;export class ErrorBoundary extends Component&lt;Props, State&gt; {&#13;&#10;  constructor(props: Props) {&#13;&#10;    super(props);&#13;&#10;    this.state = { hasError: false, error: null, errorInfo: null };&#13;&#10;  }&#13;&#10;&#13;&#10;  static getDerivedStateFromError(error: Error): State {&#13;&#10;    return {&#13;&#10;      hasError: true,&#13;&#10;      error,&#13;&#10;      errorInfo: null,&#13;&#10;    };&#13;&#10;  }&#13;&#10;&#13;&#10;  componentDidCatch(error: Error, errorInfo: ErrorInfo) {&#13;&#10;    console.error('ErrorBoundary caught an error:', error, errorInfo);&#13;&#10;&#13;&#10;    this.setState({&#13;&#10;      error,&#13;&#10;      errorInfo,&#13;&#10;    });&#13;&#10;&#13;&#10;    // 사용자 정의 에러 핸들러 호출&#13;&#10;    if (this.props.onError) {&#13;&#10;      this.props.onError(error, errorInfo);&#13;&#10;    }&#13;&#10;&#13;&#10;    // 에러 로깅 (실제 서비스에서는 에러 리포팅 서비스로 전송)&#13;&#10;    this.logErrorToService(error, errorInfo);&#13;&#10;  }&#13;&#10;&#13;&#10;  private logErrorToService = (error: Error, errorInfo: ErrorInfo) =&gt; {&#13;&#10;    // 여기서 실제 에러 리포팅 서비스(Sentry, LogRocket 등)로 전송할 수 있습니다&#13;&#10;    console.log('Error logged:', {&#13;&#10;      error: error.message,&#13;&#10;      stack: error.stack,&#13;&#10;      componentStack: errorInfo.componentStack,&#13;&#10;      timestamp: new Date().toISOString(),&#13;&#10;    });&#13;&#10;  };&#13;&#10;&#13;&#10;  private handleReload = () =&gt; {&#13;&#10;    window.location.reload();&#13;&#10;  };&#13;&#10;&#13;&#10;  private handleGoHome = () =&gt; {&#13;&#10;    window.location.href = '/';&#13;&#10;  };&#13;&#10;&#13;&#10;  private handleRetry = () =&gt; {&#13;&#10;    this.setState({ hasError: false, error: null, errorInfo: null });&#13;&#10;  };&#13;&#10;&#13;&#10;  render() {&#13;&#10;    if (this.state.hasError) {&#13;&#10;      // 사용자 정의 fallback UI가 있으면 사용&#13;&#10;      if (this.props.fallback) {&#13;&#10;        return this.props.fallback;&#13;&#10;      }&#13;&#10;&#13;&#10;      // 기본 에러 UI&#13;&#10;      return (&#13;&#10;        &lt;div className=&quot;min-h-screen flex items-center justify-center bg-gray-50 dark:bg-zinc-900&quot;&gt;&#13;&#10;          &lt;div className=&quot;max-w-md w-full bg-white dark:bg-zinc-800 rounded-lg shadow-lg p-6 border border-gray-200 dark:border-zinc-700&quot;&gt;&#13;&#10;            &lt;div className=&quot;flex items-center justify-center w-12 h-12 mx-auto bg-red-100 dark:bg-red-900/20 rounded-full mb-4&quot;&gt;&#13;&#10;              &lt;AlertTriangle className=&quot;w-6 h-6 text-red-600 dark:text-red-400&quot; /&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;&#13;&#10;            &lt;h1 className=&quot;text-xl font-semibold text-gray-900 dark:text-gray-100 text-center mb-2&quot;&gt;&#13;&#10;              앗, 문제가 발생했습니다!&#13;&#10;            &lt;/h1&gt;&#13;&#10;&#13;&#10;            &lt;p className=&quot;text-gray-600 dark:text-gray-300 text-center mb-6&quot;&gt;&#13;&#10;              예상치 못한 오류가 발생했습니다. 페이지를 새로고침하거나 홈으로 돌아가 보세요.&#13;&#10;            &lt;/p&gt;&#13;&#10;&#13;&#10;            {/* 개발 환경에서만 에러 세부 정보 표시 */}&#13;&#10;            {process.env.NODE_ENV === 'development' &amp;&amp; this.state.error &amp;&amp; (&#13;&#10;              &lt;details className=&quot;mb-4 p-3 bg-gray-100 dark:bg-zinc-700 rounded text-sm&quot;&gt;&#13;&#10;                &lt;summary className=&quot;cursor-pointer font-medium text-gray-700 dark:text-gray-300&quot;&gt;&#13;&#10;                  에러 세부 정보 (개발 모드)&#13;&#10;                &lt;/summary&gt;&#13;&#10;                &lt;div className=&quot;mt-2 text-red-600 dark:text-red-400 font-mono text-xs whitespace-pre-wrap&quot;&gt;&#13;&#10;                  {this.state.error.message}&#13;&#10;                  {this.state.error.stack &amp;&amp; (&#13;&#10;                    &lt;div className=&quot;mt-2 opacity-75&quot;&gt;&#13;&#10;                      {this.state.error.stack}&#13;&#10;                    &lt;/div&gt;&#13;&#10;                  )}&#13;&#10;                &lt;/div&gt;&#13;&#10;              &lt;/details&gt;&#13;&#10;            )}&#13;&#10;&#13;&#10;            &lt;div className=&quot;flex flex-col sm:flex-row gap-3&quot;&gt;&#13;&#10;              &lt;Button&#13;&#10;                onClick={this.handleRetry}&#13;&#10;                className=&quot;flex-1 flex items-center justify-center gap-2&quot;&#13;&#10;                variant=&quot;outline&quot;&#13;&#10;              &gt;&#13;&#10;                &lt;RefreshCw className=&quot;w-4 h-4&quot; /&gt;&#13;&#10;                다시 시도&#13;&#10;              &lt;/Button&gt;&#13;&#10;&#13;&#10;              &lt;Button&#13;&#10;                onClick={this.handleReload}&#13;&#10;                className=&quot;flex-1 flex items-center justify-center gap-2&quot;&#13;&#10;                variant=&quot;outline&quot;&#13;&#10;              &gt;&#13;&#10;                &lt;RefreshCw className=&quot;w-4 h-4&quot; /&gt;&#13;&#10;                새로고침&#13;&#10;              &lt;/Button&gt;&#13;&#10;&#13;&#10;              &lt;Button&#13;&#10;                onClick={this.handleGoHome}&#13;&#10;                className=&quot;flex-1 flex items-center justify-center gap-2&quot;&#13;&#10;              &gt;&#13;&#10;                &lt;Home className=&quot;w-4 h-4&quot; /&gt;&#13;&#10;                홈으로&#13;&#10;              &lt;/Button&gt;&#13;&#10;            &lt;/div&gt;&#13;&#10;          &lt;/div&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      );&#13;&#10;    }&#13;&#10;&#13;&#10;    return this.props.children;&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;// 특정 컴포넌트를 위한 간단한 에러 바운더리 HOC&#13;&#10;export function withErrorBoundary&lt;P extends object&gt;(&#13;&#10;  Component: React.ComponentType&lt;P&gt;,&#13;&#10;  fallback?: ReactNode&#13;&#10;) {&#13;&#10;  const WrappedComponent = (props: P) =&gt; (&#13;&#10;    &lt;ErrorBoundary fallback={fallback}&gt;&#13;&#10;      &lt;Component {...props} /&gt;&#13;&#10;    &lt;/ErrorBoundary&gt;&#13;&#10;  );&#13;&#10;&#13;&#10;  WrappedComponent.displayName = `withErrorBoundary(${Component.displayName || Component.name})`;&#13;&#10;  return WrappedComponent;&#13;&#10;}&#13;&#10;&#13;&#10;// 함수형 컴포넌트를 위한 훅&#13;&#10;export function useErrorHandler() {&#13;&#10;  return (error: Error, errorInfo?: Record&lt;string, unknown&gt;) =&gt; {&#13;&#10;    console.error('Manual error report:', error, errorInfo);&#13;&#10;    &#13;&#10;    // 여기서 에러 리포팅 서비스로 전송&#13;&#10;    if (typeof window !== 'undefined') {&#13;&#10;      // 실제 구현에서는 에러 서비스 API 호출&#13;&#10;      console.log('Error reported to service:', {&#13;&#10;        error: error.message,&#13;&#10;        stack: error.stack,&#13;&#10;        userAgent: navigator.userAgent,&#13;&#10;        url: window.location.href,&#13;&#10;        timestamp: new Date().toISOString(),&#13;&#10;        additionalInfo: errorInfo,&#13;&#10;      });&#13;&#10;    }&#13;&#10;  };&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/load-from-gist-modal.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/load-from-gist-modal.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;import React, { useState } from &quot;react&quot;;&#10;import { Button } from &quot;@/components/ui/button&quot;;&#10;import { Input } from &quot;@/components/ui/input&quot;;&#10;import { Label } from &quot;@/components/ui/label&quot;;&#10;import { X } from &quot;lucide-react&quot;;&#10;import { toast } from &quot;sonner&quot;;&#10;import { loadFromGist, isValidGistUrl, type CollectionData } from &quot;@/services/gist&quot;;&#10;&#10;interface LoadFromGistModalProps {&#10;  onClose: () =&gt; void;&#10;  onLoad: (data: CollectionData) =&gt; void;&#10;}&#10;&#10;export function LoadFromGistModal({ onClose, onLoad }: LoadFromGistModalProps) {&#10;  const [gistUrl, setGistUrl] = useState(&quot;&quot;);&#10;  const [isLoading, setIsLoading] = useState(false);&#10;&#10;  const handleLoad = async () =&gt; {&#10;    if (!gistUrl.trim()) {&#10;      toast.error(&quot;Gist URL을 입력해주세요.&quot;);&#10;      return;&#10;    }&#10;&#10;    if (!isValidGistUrl(gistUrl.trim())) {&#10;      toast.error(&quot;올바른 GitHub Gist URL을 입력해주세요.&quot;);&#10;      return;&#10;    }&#10;&#10;    setIsLoading(true);&#10;    try {&#10;      const data = await loadFromGist(gistUrl.trim());&#10;      onLoad(data);&#10;      toast.success(&quot;컬렉션을 성공적으로 불러왔습니다!&quot;);&#10;      onClose();&#10;    } catch (error) {&#10;      console.error(&quot;Gist 로드 오류:&quot;, error);&#10;      toast.error(error instanceof Error ? error.message : &quot;컬렉션을 불러오는데 실패했습니다.&quot;);&#10;    } finally {&#10;      setIsLoading(false);&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;fixed inset-0 bg-black/40 flex items-center justify-center z-50 animate-fadein&quot;&gt;&#10;      &lt;div className=&quot;relative w-full max-w-md bg-white dark:bg-zinc-900 rounded-xl shadow-lg border border-zinc-200 dark:border-zinc-800 p-6&quot;&gt;&#10;        &lt;h2 className=&quot;text-xl font-bold mb-4&quot;&gt;Gist에서 컬렉션 불러오기&lt;/h2&gt;&#10;        &lt;button&#10;          className=&quot;absolute top-3 right-3 text-zinc-500 hover:text-zinc-800 dark:hover:text-zinc-200 transition-colors&quot;&#10;          onClick={onClose}&#10;          aria-label=&quot;닫기&quot;&#10;        &gt;&#10;          &lt;X className=&quot;w-6 h-6&quot; /&gt;&#10;        &lt;/button&gt;&#10;&#10;        &lt;div className=&quot;mb-4&quot;&gt;&#10;          &lt;Label htmlFor=&quot;gist-url&quot; className=&quot;block text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-2&quot;&gt;&#10;            GitHub Gist URL&#10;          &lt;/Label&gt;&#10;          &lt;Input&#10;            id=&quot;gist-url&quot;&#10;            type=&quot;url&quot;&#10;            value={gistUrl}&#10;            onChange={(e) =&gt; setGistUrl(e.target.value)}&#10;            className=&quot;w-full px-3 py-2 border border-zinc-300 dark:border-zinc-700 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm bg-white dark:bg-zinc-800 text-zinc-900 dark:text-zinc-100&quot;&#10;            placeholder=&quot;https://gist.github.com/username/gist-id&quot;&#10;          /&gt;&#10;          &lt;p className=&quot;mt-1 text-xs text-zinc-500 dark:text-zinc-400&quot;&gt;&#10;            공유받은 GitHub Gist URL을 입력하세요&#10;          &lt;/p&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;div className=&quot;flex justify-end space-x-2&quot;&gt;&#10;          &lt;Button variant=&quot;outline&quot; onClick={onClose} disabled={isLoading}&gt;&#10;            취소&#10;          &lt;/Button&gt;&#10;          &lt;Button onClick={handleLoad} disabled={isLoading || !gistUrl.trim()}&gt;&#10;            {isLoading ? &quot;불러오는 중...&quot; : &quot;불러오기&quot;}&#10;          &lt;/Button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#13;&#10;&#13;&#10;import React, { useState } from &quot;react&quot;;&#13;&#10;import { Button } from &quot;@/components/ui/button&quot;;&#13;&#10;import { Input } from &quot;@/components/ui/input&quot;;&#13;&#10;import { Label } from &quot;@/components/ui/label&quot;;&#13;&#10;import { X } from &quot;lucide-react&quot;;&#13;&#10;import { toast } from &quot;sonner&quot;;&#13;&#10;import { useApiCall } from &quot;@/lib/useAsyncState&quot;;&#13;&#10;import { loadFromGist, isValidGistUrl, type CollectionData } from &quot;@/services/gist&quot;;&#13;&#10;&#13;&#10;interface LoadFromGistModalProps {&#13;&#10;  onClose: () =&gt; void;&#13;&#10;  onLoad: (data: CollectionData) =&gt; void;&#13;&#10;}&#13;&#10;&#13;&#10;export function LoadFromGistModal({ onClose, onLoad }: LoadFromGistModalProps) {&#13;&#10;  const [gistUrl, setGistUrl] = useState(&quot;&quot;);&#13;&#10;  const { isLoading, execute } = useApiCall&lt;CollectionData&gt;();&#13;&#10;&#13;&#10;  const handleLoad = async () =&gt; {&#13;&#10;    if (!gistUrl.trim()) {&#13;&#10;      toast.error(&quot;Gist URL을 입력해주세요.&quot;);&#13;&#10;      return;&#13;&#10;    }&#13;&#10;&#13;&#10;    if (!isValidGistUrl(gistUrl.trim())) {&#13;&#10;      toast.error(&quot;올바른 GitHub Gist URL을 입력해주세요.&quot;);&#13;&#10;      return;&#13;&#10;    }&#13;&#10;&#13;&#10;    await execute(async () =&gt; {&#13;&#10;      const data = await loadFromGist(gistUrl.trim());&#13;&#10;      onLoad(data);&#13;&#10;      toast.success(&quot;컬렉션을 성공적으로 불러왔습니다!&quot;);&#13;&#10;      onClose();&#13;&#10;      return data;&#13;&#10;    });&#13;&#10;  };&#13;&#10;&#13;&#10;  return (&#13;&#10;    &lt;div className=&quot;fixed inset-0 bg-black/40 flex items-center justify-center z-50 animate-fadein&quot;&gt;&#13;&#10;      &lt;div className=&quot;relative w-full max-w-md bg-white dark:bg-zinc-900 rounded-xl shadow-lg border border-zinc-200 dark:border-zinc-800 p-6&quot;&gt;&#13;&#10;        &lt;h2 className=&quot;text-xl font-bold mb-4&quot;&gt;Gist에서 컬렉션 불러오기&lt;/h2&gt;&#13;&#10;        &lt;button&#13;&#10;          className=&quot;absolute top-3 right-3 text-zinc-500 hover:text-zinc-800 dark:hover:text-zinc-200 transition-colors&quot;&#13;&#10;          onClick={onClose}&#13;&#10;          aria-label=&quot;닫기&quot;&#13;&#10;        &gt;&#13;&#10;          &lt;X className=&quot;w-6 h-6&quot; /&gt;&#13;&#10;        &lt;/button&gt;&#13;&#10;&#13;&#10;        &lt;div className=&quot;mb-4&quot;&gt;&#13;&#10;          &lt;Label htmlFor=&quot;gist-url&quot; className=&quot;block text-sm font-medium text-zinc-700 dark:text-zinc-300 mb-2&quot;&gt;&#13;&#10;            GitHub Gist URL&#13;&#10;          &lt;/Label&gt;&#13;&#10;          &lt;Input&#13;&#10;            id=&quot;gist-url&quot;&#13;&#10;            type=&quot;url&quot;&#13;&#10;            value={gistUrl}&#13;&#10;            onChange={(e) =&gt; setGistUrl(e.target.value)}&#13;&#10;            className=&quot;w-full px-3 py-2 border border-zinc-300 dark:border-zinc-700 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm bg-white dark:bg-zinc-800 text-zinc-900 dark:text-zinc-100&quot;&#13;&#10;            placeholder=&quot;https://gist.github.com/username/gist-id&quot;&#13;&#10;          /&gt;&#13;&#10;          &lt;p className=&quot;mt-1 text-xs text-zinc-500 dark:text-zinc-400&quot;&gt;&#13;&#10;            공유받은 GitHub Gist URL을 입력하세요&#13;&#10;          &lt;/p&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;&#13;&#10;        &lt;div className=&quot;flex justify-end space-x-2&quot;&gt;&#13;&#10;          &lt;Button variant=&quot;outline&quot; onClick={onClose} disabled={isLoading}&gt;&#13;&#10;            취소&#13;&#10;          &lt;/Button&gt;&#13;&#10;          &lt;Button onClick={handleLoad} disabled={isLoading || !gistUrl.trim()}&gt;&#13;&#10;            {isLoading ? &quot;불러오는 중...&quot; : &quot;불러오기&quot;}&#13;&#10;          &lt;/Button&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    &lt;/div&gt;&#13;&#10;  );&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/storage-connection-modal.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/storage-connection-modal.tsx" />
              <option name="originalContent" value="import * as React from 'react';&#10;import { StorageProvider } from '@/types/storage';&#10;import { storageManager } from '@/lib/storage-manager';&#10;import { Cloud, HardDrive, Loader2, X, Info } from 'lucide-react';&#10;&#10;interface StorageConnectionModalProps {&#10;  onClose: () =&gt; void;&#10;  onConnectionSelected: (provider: StorageProvider) =&gt; void;&#10;}&#10;&#10;export function StorageConnectionModal({ onClose, onConnectionSelected }: StorageConnectionModalProps) {&#10;  const modalRef = React.useRef&lt;HTMLDivElement&gt;(null);&#10;  const [isConnecting, setIsConnecting] = React.useState(false);&#10;  const [connectingProvider, setConnectingProvider] = React.useState&lt;StorageProvider | null&gt;(null);&#10;&#10;  // 키보드 이벤트 처리&#10;  React.useEffect(() =&gt; {&#10;    const handleKeyDown = (e: KeyboardEvent) =&gt; {&#10;      if (e.key === 'Escape' &amp;&amp; !isConnecting) {&#10;        e.preventDefault();&#10;        e.stopPropagation();&#10;        onClose();&#10;      }&#10;      &#10;      // Tab 키 트랩핑&#10;      if (e.key === 'Tab' &amp;&amp; modalRef.current) {&#10;        const focusable = modalRef.current.querySelectorAll&lt;HTMLElement&gt;(&#10;          'a[href], button:not([disabled]), textarea, input, select, [tabindex]:not([tabindex=&quot;-1&quot;])'&#10;        );&#10;        if (focusable.length === 0) return;&#10;        const first = focusable[0];&#10;        const last = focusable[focusable.length - 1];&#10;        if (!e.shiftKey &amp;&amp; document.activeElement === last) {&#10;          e.preventDefault();&#10;          first.focus();&#10;        } else if (e.shiftKey &amp;&amp; document.activeElement === first) {&#10;          e.preventDefault();&#10;          last.focus();&#10;        }&#10;      }&#10;    };&#10;&#10;    document.addEventListener('keydown', handleKeyDown);&#10;    return () =&gt; document.removeEventListener('keydown', handleKeyDown);&#10;  }, [onClose, isConnecting]);&#10;&#10;  // 오버레이 클릭 처리&#10;  const handleOverlayClick = (e: React.MouseEvent&lt;HTMLDivElement&gt;) =&gt; {&#10;    if (e.target === e.currentTarget &amp;&amp; !isConnecting) {&#10;      onClose();&#10;    }&#10;  };&#10;&#10;  const handleProviderSelect = async (provider: StorageProvider) =&gt; {&#10;    if (provider === 'local') {&#10;      onConnectionSelected(provider);&#10;      return;&#10;    }&#10;&#10;    try {&#10;      setIsConnecting(true);&#10;      setConnectingProvider(provider);&#10;      &#10;      await storageManager.connectToProvider(provider);&#10;      onConnectionSelected(provider);&#10;    } catch (error) {&#10;      console.error(`Failed to connect to ${provider}:`, error);&#10;      &#10;      // Show detailed error message&#10;      const errorMessage = error instanceof Error ? error.message : '알 수 없는 오류가 발생했습니다.';&#10;      alert(`${storageManager.getProviderDisplayName(provider)} 연결 실패:\n\n${errorMessage}`);&#10;    } finally {&#10;      setIsConnecting(false);&#10;      setConnectingProvider(null);&#10;    }&#10;  };&#10;&#10;  const handleShowSetupGuide = () =&gt; {&#10;    const guideMessage = `클라우드 스토리지 연동 설정 방법:&#10;&#10; Dropbox 설정:&#10;1. https://www.dropbox.com/developers/apps 방문&#10;2. &quot;Create app&quot; 클릭&#10;3. &quot;Scoped access&quot; 선택&#10;4. &quot;App folder&quot; 또는 &quot;Full Dropbox&quot; 선택  &#10;5. 앱 이름 입력&#10;6. App key를 복사하여 NEXT_PUBLIC_DROPBOX_CLIENT_ID에 설정&#10;7. App secret을 복사하여 DROPBOX_CLIENT_SECRET에 설정&#10;8. OAuth2 redirect URL에 다음 추가:&#10;   http://localhost:3000/auth/dropbox/callback&#10;&#10; Google Drive 설정:&#10;1. https://console.developers.google.com 방문&#10;2. 새 프로젝트 생성 또는 선택&#10;3. &quot;APIs &amp; Services&quot; &gt; &quot;Library&quot; 에서 Google Drive API 활성화&#10;4. &quot;Credentials&quot; &gt; &quot;Create Credentials&quot; &gt; &quot;OAuth 2.0 Client IDs&quot;&#10;5. 애플리케이션 유형을 &quot;Web application&quot; 선택&#10;6. 승인된 JavaScript 원본에 http://localhost:3000 추가&#10;7. 클라이언트 ID를 NEXT_PUBLIC_GOOGLE_CLIENT_ID에 설정&#10;8. API 키도 생성하여 NEXT_PUBLIC_GOOGLE_API_KEY에 설정&#10;&#10;.env.local 파일에 환경 변수를 설정한 후 개발 서버를 재시작하세요.`;&#10;    &#10;    alert(guideMessage);&#10;  };&#10;&#10;  const providers: Array&lt;{&#10;    id: StorageProvider;&#10;    name: string;&#10;    description: string;&#10;    icon: React.ReactNode;&#10;    color: string;&#10;  }&gt; = [&#10;    {&#10;      id: 'local',&#10;      name: '로컬 파일',&#10;      description: '컴퓨터의 파일을 직접 불러오거나 저장합니다',&#10;      icon: &lt;HardDrive className=&quot;h-8 w-8&quot; /&gt;,&#10;      color: 'bg-gray-500 hover:bg-gray-600'&#10;    },&#10;    {&#10;      id: 'dropbox',&#10;      name: 'Dropbox',&#10;      description: 'Dropbox 클라우드 스토리지와 연동합니다',&#10;      icon: &lt;Cloud className=&quot;h-8 w-8&quot; /&gt;,&#10;      color: 'bg-blue-500 hover:bg-blue-600'&#10;    },&#10;    {&#10;      id: 'googledrive',&#10;      name: 'Google Drive',&#10;      description: 'Google Drive 클라우드 스토리지와 연동합니다',&#10;      icon: &lt;Cloud className=&quot;h-8 w-8&quot; /&gt;,&#10;      color: 'bg-green-500 hover:bg-green-600'&#10;    }&#10;  ];&#10;&#10;  return (&#10;    &lt;div &#10;      className=&quot;fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4&quot;&#10;      onClick={handleOverlayClick}&#10;    &gt;&#10;      &lt;div &#10;        ref={modalRef}&#10;        className=&quot;relative w-full max-w-2xl bg-white dark:bg-zinc-900 rounded-xl shadow-lg border border-zinc-200 dark:border-zinc-800 max-h-[90vh] overflow-hidden&quot;&#10;        onClick={(e) =&gt; e.stopPropagation()}&#10;        role=&quot;dialog&quot;&#10;        aria-labelledby=&quot;storage-connection-title&quot;&#10;        aria-modal=&quot;true&quot;&#10;      &gt;&#10;        {/* Header */}&#10;        &lt;div className=&quot;p-6 pb-0 border-b border-zinc-200 dark:border-zinc-800&quot;&gt;&#10;          &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;            &lt;h2 id=&quot;storage-connection-title&quot; className=&quot;text-2xl font-bold text-zinc-900 dark:text-zinc-100&quot;&gt;&#10;              파일 연동 방식 선택&#10;            &lt;/h2&gt;&#10;            &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;              &lt;button&#10;                onClick={onClose}&#10;                disabled={isConnecting}&#10;                className=&quot;text-zinc-500 hover:text-zinc-800 dark:hover:text-zinc-200 transition-colors disabled:opacity-50 disabled:cursor-not-allowed&quot;&#10;                aria-label=&quot;닫기&quot;&#10;              &gt;&#10;                &lt;X className=&quot;w-6 h-6&quot; /&gt;&#10;              &lt;/button&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;          &lt;p className=&quot;text-zinc-600 dark:text-zinc-400 mt-2&quot;&gt;&#10;            컬렉션 파일을 저장하고 불러올 방식을 선택해주세요.&#10;          &lt;/p&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Content */}&#10;        &lt;div className=&quot;p-6&quot;&gt;&#10;          &lt;div className=&quot;grid gap-4&quot;&gt;&#10;            {providers.map((provider) =&gt; (&#10;              &lt;button&#10;                key={provider.id}&#10;                onClick={() =&gt; handleProviderSelect(provider.id)}&#10;                disabled={isConnecting}&#10;                className=&quot;flex items-center gap-4 p-4 border border-zinc-200 dark:border-zinc-700 rounded-lg hover:border-zinc-300 dark:hover:border-zinc-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-left&quot;&#10;              &gt;&#10;                &lt;div className={`p-3 rounded-lg text-white ${provider.color} transition-colors`}&gt;&#10;                  {isConnecting &amp;&amp; connectingProvider === provider.id ? (&#10;                    &lt;Loader2 className=&quot;h-8 w-8 animate-spin&quot; /&gt;&#10;                  ) : (&#10;                    provider.icon&#10;                  )}&#10;                &lt;/div&gt;&#10;                &lt;div className=&quot;flex-1&quot;&gt;&#10;                  &lt;h3 className=&quot;text-lg font-semibold text-zinc-900 dark:text-zinc-100&quot;&gt;&#10;                    {provider.name}&#10;                  &lt;/h3&gt;&#10;                  &lt;p className=&quot;text-sm text-zinc-600 dark:text-zinc-400&quot;&gt;&#10;                    {provider.description}&#10;                  &lt;/p&gt;&#10;                  {isConnecting &amp;&amp; connectingProvider === provider.id &amp;&amp; (&#10;                    &lt;p className=&quot;text-sm text-blue-600 dark:text-blue-400 mt-1&quot;&gt;&#10;                      연결 중...&#10;                    &lt;/p&gt;&#10;                  )}&#10;                &lt;/div&gt;&#10;              &lt;/button&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Loading overlay */}&#10;        {isConnecting &amp;&amp; (&#10;          &lt;div className=&quot;absolute inset-0 bg-black/20 dark:bg-black/40 flex items-center justify-center rounded-xl backdrop-blur-sm&quot;&gt;&#10;            &lt;div className=&quot;bg-white dark:bg-zinc-800 p-6 rounded-lg shadow-lg border border-zinc-200 dark:border-zinc-700 flex flex-col items-center gap-4&quot;&gt;&#10;              &lt;Loader2 className=&quot;h-8 w-8 animate-spin text-blue-600&quot; /&gt;&#10;              &lt;div className=&quot;text-center&quot;&gt;&#10;                &lt;p className=&quot;font-medium text-zinc-900 dark:text-zinc-100&quot;&gt;&#10;                  {storageManager.getProviderDisplayName(connectingProvider!)}에 연결 중...&#10;                &lt;/p&gt;&#10;                &lt;p className=&quot;text-sm text-zinc-600 dark:text-zinc-400 mt-1&quot;&gt;&#10;                  새 창에서 인증을 완료해주세요&#10;                &lt;/p&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import * as React from 'react';&#10;import { StorageProvider } from '@/types/storage';&#10;import { storageManager } from '@/lib/storage-manager';&#10;import { Cloud, HardDrive, Loader2, X } from 'lucide-react';&#10;&#10;interface StorageConnectionModalProps {&#10;  onClose: () =&gt; void;&#10;  onConnectionSelected: (provider: StorageProvider) =&gt; void;&#10;}&#10;&#10;export function StorageConnectionModal({ onClose, onConnectionSelected }: StorageConnectionModalProps) {&#10;  const modalRef = React.useRef&lt;HTMLDivElement&gt;(null);&#10;  const [isConnecting, setIsConnecting] = React.useState(false);&#10;  const [connectingProvider, setConnectingProvider] = React.useState&lt;StorageProvider | null&gt;(null);&#10;&#10;  // 키보드 이벤트 처리&#10;  React.useEffect(() =&gt; {&#10;    const handleKeyDown = (e: KeyboardEvent) =&gt; {&#10;      if (e.key === 'Escape' &amp;&amp; !isConnecting) {&#10;        e.preventDefault();&#10;        e.stopPropagation();&#10;        onClose();&#10;      }&#10;      &#10;      // Tab 키 트랩핑&#10;      if (e.key === 'Tab' &amp;&amp; modalRef.current) {&#10;        const focusable = modalRef.current.querySelectorAll&lt;HTMLElement&gt;(&#10;          'a[href], button:not([disabled]), textarea, input, select, [tabindex]:not([tabindex=&quot;-1&quot;])'&#10;        );&#10;        if (focusable.length === 0) return;&#10;        const first = focusable[0];&#10;        const last = focusable[focusable.length - 1];&#10;        if (!e.shiftKey &amp;&amp; document.activeElement === last) {&#10;          e.preventDefault();&#10;          first.focus();&#10;        } else if (e.shiftKey &amp;&amp; document.activeElement === first) {&#10;          e.preventDefault();&#10;          last.focus();&#10;        }&#10;      }&#10;    };&#10;&#10;    document.addEventListener('keydown', handleKeyDown);&#10;    return () =&gt; document.removeEventListener('keydown', handleKeyDown);&#10;  }, [onClose, isConnecting]);&#10;&#10;  // 오버레이 클릭 처리&#10;  const handleOverlayClick = (e: React.MouseEvent&lt;HTMLDivElement&gt;) =&gt; {&#10;    if (e.target === e.currentTarget &amp;&amp; !isConnecting) {&#10;      onClose();&#10;    }&#10;  };&#10;&#10;  const handleProviderSelect = async (provider: StorageProvider) =&gt; {&#10;    if (provider === 'local') {&#10;      onConnectionSelected(provider);&#10;      return;&#10;    }&#10;&#10;    try {&#10;      setIsConnecting(true);&#10;      setConnectingProvider(provider);&#10;      &#10;      await storageManager.connectToProvider(provider);&#10;      onConnectionSelected(provider);&#10;    } catch (error) {&#10;      console.error(`Failed to connect to ${provider}:`, error);&#10;      &#10;      // Show detailed error message&#10;      const errorMessage = error instanceof Error ? error.message : '알 수 없는 오류가 발생했습니다.';&#10;      alert(`연결 실패:\n\n${errorMessage}`);&#10;    } finally {&#10;      setIsConnecting(false);&#10;      setConnectingProvider(null);&#10;    }&#10;  };&#10;&#10;  const providers: Array&lt;{&#10;    id: StorageProvider;&#10;    name: string;&#10;    description: string;&#10;    icon: React.ReactNode;&#10;    color: string;&#10;  }&gt; = [&#10;    {&#10;      id: 'local',&#10;      name: '로컬 파일',&#10;      description: '컴퓨터의 파일을 직접 불러오거나 저장합니다',&#10;      icon: &lt;HardDrive className=&quot;h-8 w-8&quot; /&gt;,&#10;      color: 'bg-gray-500 hover:bg-gray-600'&#10;    },&#10;    {&#10;      id: 'dropbox',&#10;      name: 'Dropbox',&#10;      description: 'Dropbox 클라우드 스토리지와 연동합니다',&#10;      icon: &lt;Cloud className=&quot;h-8 w-8&quot; /&gt;,&#10;      color: 'bg-blue-500 hover:bg-blue-600'&#10;    },&#10;    {&#10;      id: 'googledrive',&#10;      name: 'Google Drive',&#10;      description: 'Google Drive 클라우드 스토리지와 연동합니다',&#10;      icon: &lt;Cloud className=&quot;h-8 w-8&quot; /&gt;,&#10;      color: 'bg-green-500 hover:bg-green-600'&#10;    }&#10;  ];&#10;&#10;  return (&#10;    &lt;div &#10;      className=&quot;fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4&quot;&#10;      onClick={handleOverlayClick}&#10;    &gt;&#10;      &lt;div &#10;        ref={modalRef}&#10;        className=&quot;relative w-full max-w-2xl bg-white dark:bg-zinc-900 rounded-xl shadow-lg border border-zinc-200 dark:border-zinc-800 max-h-[90vh] overflow-hidden&quot;&#10;        onClick={(e) =&gt; e.stopPropagation()}&#10;        role=&quot;dialog&quot;&#10;        aria-labelledby=&quot;storage-connection-title&quot;&#10;        aria-modal=&quot;true&quot;&#10;      &gt;&#10;        {/* Header */}&#10;        &lt;div className=&quot;p-6 pb-0 border-b border-zinc-200 dark:border-zinc-800&quot;&gt;&#10;          &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;            &lt;h2 id=&quot;storage-connection-title&quot; className=&quot;text-2xl font-bold text-zinc-900 dark:text-zinc-100&quot;&gt;&#10;              파일 연동 방식 선택&#10;            &lt;/h2&gt;&#10;            &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;              &lt;button&#10;                onClick={onClose}&#10;                disabled={isConnecting}&#10;                className=&quot;text-zinc-500 hover:text-zinc-800 dark:hover:text-zinc-200 transition-colors disabled:opacity-50 disabled:cursor-not-allowed&quot;&#10;                aria-label=&quot;닫기&quot;&#10;              &gt;&#10;                &lt;X className=&quot;w-6 h-6&quot; /&gt;&#10;              &lt;/button&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;          &lt;p className=&quot;text-zinc-600 dark:text-zinc-400 mt-2&quot;&gt;&#10;            컬렉션 파일을 저장하고 불러올 방식을 선택해주세요.&#10;          &lt;/p&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Content */}&#10;        &lt;div className=&quot;p-6&quot;&gt;&#10;          &lt;div className=&quot;grid gap-4&quot;&gt;&#10;            {providers.map((provider) =&gt; (&#10;              &lt;button&#10;                key={provider.id}&#10;                onClick={() =&gt; handleProviderSelect(provider.id)}&#10;                disabled={isConnecting}&#10;                className=&quot;flex items-center gap-4 p-4 border border-zinc-200 dark:border-zinc-700 rounded-lg hover:border-zinc-300 dark:hover:border-zinc-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed text-left&quot;&#10;              &gt;&#10;                &lt;div className={`p-3 rounded-lg text-white ${provider.color} transition-colors`}&gt;&#10;                  {isConnecting &amp;&amp; connectingProvider === provider.id ? (&#10;                    &lt;Loader2 className=&quot;h-8 w-8 animate-spin&quot; /&gt;&#10;                  ) : (&#10;                    provider.icon&#10;                  )}&#10;                &lt;/div&gt;&#10;                &lt;div className=&quot;flex-1&quot;&gt;&#10;                  &lt;h3 className=&quot;text-lg font-semibold text-zinc-900 dark:text-zinc-100&quot;&gt;&#10;                    {provider.name}&#10;                  &lt;/h3&gt;&#10;                  &lt;p className=&quot;text-sm text-zinc-600 dark:text-zinc-400&quot;&gt;&#10;                    {provider.description}&#10;                  &lt;/p&gt;&#10;                  {isConnecting &amp;&amp; connectingProvider === provider.id &amp;&amp; (&#10;                    &lt;p className=&quot;text-sm text-blue-600 dark:text-blue-400 mt-1&quot;&gt;&#10;                      연결 중...&#10;                    &lt;/p&gt;&#10;                  )}&#10;                &lt;/div&gt;&#10;              &lt;/button&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Loading overlay */}&#10;        {isConnecting &amp;&amp; (&#10;          &lt;div className=&quot;absolute inset-0 bg-black/20 dark:bg-black/40 flex items-center justify-center rounded-xl backdrop-blur-sm&quot;&gt;&#10;            &lt;div className=&quot;bg-white dark:bg-zinc-800 p-6 rounded-lg shadow-lg border border-zinc-200 dark:border-zinc-700 flex flex-col items-center gap-4&quot;&gt;&#10;              &lt;Loader2 className=&quot;h-8 w-8 animate-spin text-blue-600&quot; /&gt;&#10;              &lt;div className=&quot;text-center&quot;&gt;&#10;                &lt;p className=&quot;font-medium text-zinc-900 dark:text-zinc-100&quot;&gt;&#10;                  {storageManager.getProviderDisplayName(connectingProvider!)}에 연결 중...&#10;                &lt;/p&gt;&#10;                &lt;p className=&quot;text-sm text-zinc-600 dark:text-zinc-400 mt-1&quot;&gt;&#10;                  새 창에서 인증을 완료해주세요&#10;                &lt;/p&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/lib/error-handler.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/lib/error-handler.ts" />
              <option name="updatedContent" value="export class APIError extends Error {&#10;  constructor(&#10;    message: string,&#10;    public status?: number,&#10;    public service?: string,&#10;    public originalError?: unknown&#10;  ) {&#10;    super(message);&#10;    this.name = 'APIError';&#10;  }&#10;}&#10;&#10;export class AuthenticationError extends APIError {&#10;  constructor(service?: string) {&#10;    super(`${service ? `${service} ` : ''}인증이 필요합니다.`, 401, service);&#10;    this.name = 'AuthenticationError';&#10;  }&#10;}&#10;&#10;export class NetworkError extends APIError {&#10;  constructor(service?: string, status?: number, originalError?: unknown) {&#10;    super(`${service ? `${service} ` : ''}네트워크 오류가 발생했습니다.`, status, service, originalError);&#10;    this.name = 'NetworkError';&#10;  }&#10;}&#10;&#10;export class ValidationError extends APIError {&#10;  constructor(message: string, service?: string) {&#10;    super(message, 400, service);&#10;    this.name = 'ValidationError';&#10;  }&#10;}&#10;&#10;export interface ErrorHandlerOptions {&#10;  showToast?: boolean;&#10;  fallbackMessage?: string;&#10;  logError?: boolean;&#10;}&#10;&#10;/**&#10; * API 에러를 일관된 방식으로 처리하는 유틸리티 함수&#10; */&#10;export const handleAPIError = (&#10;  error: unknown, &#10;  service: string,&#10;  options: ErrorHandlerOptions = {}&#10;): APIError =&gt; {&#10;  const { fallbackMessage = '알 수 없는 오류가 발생했습니다.', logError = true } = options;&#10;&#10;  if (logError) {&#10;    console.error(`[${service}] Error:`, error);&#10;  }&#10;&#10;  // 이미 APIError 인스턴스인 경우&#10;  if (error instanceof APIError) {&#10;    return error;&#10;  }&#10;&#10;  // Response 객체인 경우&#10;  if (error instanceof Response) {&#10;    if (error.status === 401) {&#10;      return new AuthenticationError(service);&#10;    }&#10;    return new NetworkError(service, error.status);&#10;  }&#10;&#10;  // 일반 Error 객체인 경우&#10;  if (error instanceof Error) {&#10;    if (error.message.includes('Not authenticated') || error.message.includes('Authentication')) {&#10;      return new AuthenticationError(service);&#10;    }&#10;    if (error.message.includes('Failed to') || error.message.includes('Network')) {&#10;      return new NetworkError(service, undefined, error);&#10;    }&#10;    return new APIError(error.message, undefined, service, error);&#10;  }&#10;&#10;  // 기타 경우&#10;  return new APIError(fallbackMessage, undefined, service, error);&#10;};&#10;&#10;/**&#10; * 환경 변수 누락 에러를 처리하는 유틸리티 함수&#10; */&#10;export const createEnvironmentError = (service: string, requiredVars: string[]): APIError =&gt; {&#10;  const message = `${service} 연동을 위해서는 환경 변수 설정이 필요합니다.&#10;&#10;필요한 환경 변수:&#10;${requiredVars.map(v =&gt; `- ${v}`).join('\n')}&#10;&#10;.env.local 파일에 해당 값들을 설정해주세요.`;&#10;&#10;  return new ValidationError(message, service);&#10;};&#10;&#10;/**&#10; * 사용자 친화적인 에러 메시지를 생성하는 함수&#10; */&#10;export const getUserFriendlyErrorMessage = (error: APIError): string =&gt; {&#10;  if (error instanceof AuthenticationError) {&#10;    return `${error.service || '서비스'} 로그인이 필요합니다. 다시 로그인해주세요.`;&#10;  }&#10;&#10;  if (error instanceof NetworkError) {&#10;    return `${error.service || '서비스'} 연결에 문제가 발생했습니다. 인터넷 연결을 확인하고 다시 시도해주세요.`;&#10;  }&#10;&#10;  if (error instanceof ValidationError) {&#10;    return error.message;&#10;  }&#10;&#10;  return error.message || '알 수 없는 오류가 발생했습니다.';&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/lib/useAsyncState.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/lib/useAsyncState.ts" />
              <option name="originalContent" value="import { useState, useCallback } from 'react';&#10;import { APIError, getUserFriendlyErrorMessage } from './error-handler';&#10;import { toast } from 'sonner';&#10;&#10;export interface AsyncState&lt;T&gt; {&#10;  data: T | null;&#10;  isLoading: boolean;&#10;  error: string | null;&#10;}&#10;&#10;export interface UseAsyncStateOptions {&#10;  showToast?: boolean;&#10;  initialData?: any;&#10;  onSuccess?: (data: any) =&gt; void;&#10;  onError?: (error: APIError) =&gt; void;&#10;}&#10;&#10;/**&#10; * 비동기 작업의 로딩, 성공, 실패 상태를 관리하는 커스텀 훅&#10; */&#10;export function useAsyncState&lt;T = any&gt;(options: UseAsyncStateOptions = {}) {&#10;  const { showToast = true, initialData = null, onSuccess, onError } = options;&#10;&#10;  const [state, setState] = useState&lt;AsyncState&lt;T&gt;&gt;({&#10;    data: initialData,&#10;    isLoading: false,&#10;    error: null,&#10;  });&#10;&#10;  const execute = useCallback(async (asyncFunction: () =&gt; Promise&lt;T&gt;) =&gt; {&#10;    setState(prev =&gt; ({ ...prev, isLoading: true, error: null }));&#10;&#10;    try {&#10;      const result = await asyncFunction();&#10;      setState({&#10;        data: result,&#10;        isLoading: false,&#10;        error: null,&#10;      });&#10;&#10;      if (onSuccess) {&#10;        onSuccess(result);&#10;      }&#10;&#10;      return result;&#10;    } catch (error) {&#10;      const apiError = error instanceof APIError ? error : new APIError('알 수 없는 오류가 발생했습니다.');&#10;      const errorMessage = getUserFriendlyErrorMessage(apiError);&#10;&#10;      setState(prev =&gt; ({&#10;        ...prev,&#10;        isLoading: false,&#10;        error: errorMessage,&#10;      }));&#10;&#10;      if (showToast) {&#10;        toast.error(errorMessage);&#10;      }&#10;&#10;      if (onError) {&#10;        onError(apiError);&#10;      }&#10;&#10;      throw apiError;&#10;    }&#10;  }, [showToast, onSuccess, onError]);&#10;&#10;  const reset = useCallback(() =&gt; {&#10;    setState({&#10;      data: initialData,&#10;      isLoading: false,&#10;      error: null,&#10;    });&#10;  }, [initialData]);&#10;&#10;  const setData = useCallback((data: T) =&gt; {&#10;    setState(prev =&gt; ({ ...prev, data }));&#10;  }, []);&#10;&#10;  const setError = useCallback((error: string) =&gt; {&#10;    setState(prev =&gt; ({ ...prev, error, isLoading: false }));&#10;  }, []);&#10;&#10;  return {&#10;    ...state,&#10;    execute,&#10;    reset,&#10;    setData,&#10;    setError,&#10;  };&#10;}&#10;&#10;/**&#10; * 파일 업로드/다운로드 등의 작업을 위한 특화된 훅&#10; */&#10;export function useFileOperation() {&#10;  return useAsyncState({&#10;    showToast: true,&#10;    onSuccess: (data) =&gt; {&#10;      if (data &amp;&amp; typeof data === 'object' &amp;&amp; 'message' in data) {&#10;        toast.success(data.message as string);&#10;      }&#10;    },&#10;  });&#10;}&#10;&#10;/**&#10; * API 호출을 위한 특화된 훅&#10; */&#10;export function useApiCall&lt;T = any&gt;(options: UseAsyncStateOptions = {}) {&#10;  return useAsyncState&lt;T&gt;({&#10;    showToast: true,&#10;    ...options,&#10;  });&#10;}&#10;" />
              <option name="updatedContent" value="import { useState, useCallback } from 'react';&#13;&#10;import { APIError, getUserFriendlyErrorMessage } from './error-handler';&#13;&#10;import { toast } from 'sonner';&#13;&#10;&#13;&#10;export interface AsyncState&lt;T&gt; {&#13;&#10;  data: T | null;&#13;&#10;  isLoading: boolean;&#13;&#10;  error: string | null;&#13;&#10;}&#13;&#10;&#13;&#10;export interface UseAsyncStateOptions&lt;T = unknown&gt; {&#13;&#10;  showToast?: boolean;&#13;&#10;  initialData?: T;&#13;&#10;  onSuccess?: (data: T) =&gt; void;&#13;&#10;  onError?: (error: APIError) =&gt; void;&#13;&#10;}&#13;&#10;&#13;&#10;/**&#13;&#10; * 비동기 작업의 로딩, 성공, 실패 상태를 관리하는 커스텀 훅&#13;&#10; */&#13;&#10;export function useAsyncState&lt;T = unknown&gt;(options: UseAsyncStateOptions&lt;T&gt; = {}) {&#13;&#10;  const { showToast = true, initialData = null, onSuccess, onError } = options;&#13;&#10;&#13;&#10;  const [state, setState] = useState&lt;AsyncState&lt;T&gt;&gt;({&#13;&#10;    data: initialData,&#13;&#10;    isLoading: false,&#13;&#10;    error: null,&#13;&#10;  });&#13;&#10;&#13;&#10;  const execute = useCallback(async (asyncFunction: () =&gt; Promise&lt;T&gt;) =&gt; {&#13;&#10;    setState(prev =&gt; ({ ...prev, isLoading: true, error: null }));&#13;&#10;&#13;&#10;    try {&#13;&#10;      const result = await asyncFunction();&#13;&#10;      setState({&#13;&#10;        data: result,&#13;&#10;        isLoading: false,&#13;&#10;        error: null,&#13;&#10;      });&#13;&#10;&#13;&#10;      if (onSuccess) {&#13;&#10;        onSuccess(result);&#13;&#10;      }&#13;&#10;&#13;&#10;      return result;&#13;&#10;    } catch (error) {&#13;&#10;      const apiError = error instanceof APIError ? error : new APIError('알 수 없는 오류가 발생했습니다.');&#13;&#10;      const errorMessage = getUserFriendlyErrorMessage(apiError);&#13;&#10;&#13;&#10;      setState(prev =&gt; ({&#13;&#10;        ...prev,&#13;&#10;        isLoading: false,&#13;&#10;        error: errorMessage,&#13;&#10;      }));&#13;&#10;&#13;&#10;      if (showToast) {&#13;&#10;        toast.error(errorMessage);&#13;&#10;      }&#13;&#10;&#13;&#10;      if (onError) {&#13;&#10;        onError(apiError);&#13;&#10;      }&#13;&#10;&#13;&#10;      throw apiError;&#13;&#10;    }&#13;&#10;  }, [showToast, onSuccess, onError]);&#13;&#10;&#13;&#10;  const reset = useCallback(() =&gt; {&#13;&#10;    setState({&#13;&#10;      data: initialData,&#13;&#10;      isLoading: false,&#13;&#10;      error: null,&#13;&#10;    });&#13;&#10;  }, [initialData]);&#13;&#10;&#13;&#10;  const setData = useCallback((data: T) =&gt; {&#13;&#10;    setState(prev =&gt; ({ ...prev, data }));&#13;&#10;  }, []);&#13;&#10;&#13;&#10;  const setError = useCallback((error: string) =&gt; {&#13;&#10;    setState(prev =&gt; ({ ...prev, error, isLoading: false }));&#13;&#10;  }, []);&#13;&#10;&#13;&#10;  return {&#13;&#10;    ...state,&#13;&#10;    execute,&#13;&#10;    reset,&#13;&#10;    setData,&#13;&#10;    setError,&#13;&#10;  };&#13;&#10;}&#13;&#10;&#13;&#10;/**&#13;&#10; * 파일 업로드/다운로드 등의 작업을 위한 특화된 훅&#13;&#10; */&#13;&#10;export function useFileOperation() {&#13;&#10;  return useAsyncState({&#13;&#10;    showToast: true,&#13;&#10;    onSuccess: (data) =&gt; {&#13;&#10;      if (data &amp;&amp; typeof data === 'object' &amp;&amp; 'message' in data) {&#13;&#10;        toast.success(data.message as string);&#13;&#10;      }&#13;&#10;    },&#13;&#10;  });&#13;&#10;}&#13;&#10;&#13;&#10;/**&#13;&#10; * API 호출을 위한 특화된 훅&#13;&#10; */&#13;&#10;export function useApiCall&lt;T = unknown&gt;(options: UseAsyncStateOptions&lt;T&gt; = {}) {&#13;&#10;  return useAsyncState&lt;T&gt;({&#13;&#10;    showToast: true,&#13;&#10;    ...options,&#13;&#10;  });&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tsconfig.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tsconfig.json" />
              <option name="originalContent" value="{&#10;  &quot;compilerOptions&quot;: {&#10;    &quot;target&quot;: &quot;ES2017&quot;,&#10;    &quot;lib&quot;: [&quot;dom&quot;, &quot;dom.iterable&quot;, &quot;esnext&quot;],&#10;    &quot;allowJs&quot;: true,&#10;    &quot;skipLibCheck&quot;: true,&#10;    &quot;strict&quot;: true,&#10;    &quot;noEmit&quot;: true,&#10;    &quot;esModuleInterop&quot;: true,&#10;    &quot;module&quot;: &quot;esnext&quot;,&#10;    &quot;moduleResolution&quot;: &quot;bundler&quot;,&#10;    &quot;resolveJsonModule&quot;: true,&#10;    &quot;isolatedModules&quot;: true,&#10;    &quot;jsx&quot;: &quot;preserve&quot;,&#10;    &quot;incremental&quot;: true,&#10;    &quot;plugins&quot;: [&#10;      {&#10;        &quot;name&quot;: &quot;next&quot;&#10;      }&#10;    ],&#10;    &quot;paths&quot;: {&#10;      &quot;@/*&quot;: [&quot;./src/*&quot;]&#10;    }&#10;  },&#10;  &quot;include&quot;: [&quot;next-env.d.ts&quot;, &quot;**/*.ts&quot;, &quot;**/*.tsx&quot;, &quot;.next/types/**/*.ts&quot;],&#10;  &quot;exclude&quot;: [&quot;node_modules&quot;]&#10;}&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;compilerOptions&quot;: {&#10;    &quot;target&quot;: &quot;ES2017&quot;,&#10;    &quot;lib&quot;: [&quot;dom&quot;, &quot;dom.iterable&quot;, &quot;esnext&quot;],&#10;    &quot;allowJs&quot;: true,&#10;    &quot;skipLibCheck&quot;: true,&#10;    &quot;strict&quot;: true,&#10;    &quot;noEmit&quot;: true,&#10;    &quot;esModuleInterop&quot;: true,&#10;    &quot;module&quot;: &quot;esnext&quot;,&#10;    &quot;moduleResolution&quot;: &quot;bundler&quot;,&#10;    &quot;resolveJsonModule&quot;: true,&#10;    &quot;isolatedModules&quot;: true,&#10;    &quot;jsx&quot;: &quot;preserve&quot;,&#10;    &quot;incremental&quot;: true,&#10;    &quot;plugins&quot;: [&#10;      {&#10;        &quot;name&quot;: &quot;next&quot;&#10;      }&#10;    ],&#10;    &quot;paths&quot;: {&#10;      &quot;@/*&quot;: [&quot;./src/*&quot;]&#10;    }&#10;  },&#10;  &quot;include&quot;: [&quot;next-env.d.ts&quot;, &quot;**/*.ts&quot;, &quot;**/*.tsx&quot;, &quot;.next/types/**/*.ts&quot;],&#10;  &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;netlify/edge-functions/**/*&quot;]&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>